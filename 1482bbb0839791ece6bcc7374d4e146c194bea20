{
  "comments": [
    {
      "key": {
        "uuid": "8ec358cb_0d36e5ae",
        "filename": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/refactoring/overridemethods/Method.java",
        "patchSetId": 12
      },
      "lineNbr": 144,
      "author": {
        "id": 598
      },
      "writtenOn": "2019-04-14T17:49:36Z",
      "side": 1,
      "message": "Are we using the factory here because a simple copy of the declarator wouldn\u0027t work? Is it because of the handling of the parameters below? Maybe there could be a comment that says why we don\u0027t simply copy.",
      "revId": "1482bbb0839791ece6bcc7374d4e146c194bea20",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "344aa896_d7b720fb",
        "filename": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/refactoring/overridemethods/Method.java",
        "patchSetId": 12
      },
      "lineNbr": 164,
      "author": {
        "id": 598
      },
      "writtenOn": "2019-04-14T17:49:36Z",
      "side": 1,
      "message": "I think there should be a small test for this, i.e.\nvirtual void * method(), method2();",
      "revId": "1482bbb0839791ece6bcc7374d4e146c194bea20",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "fefeef76_48df7909",
        "filename": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/refactoring/overridemethods/MethodCollector.java",
        "patchSetId": 12
      },
      "lineNbr": 41,
      "author": {
        "id": 598
      },
      "writtenOn": "2019-04-14T17:49:36Z",
      "side": 1,
      "message": "good catch!",
      "revId": "1482bbb0839791ece6bcc7374d4e146c194bea20",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dd5cfb00_7f439061",
        "filename": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/refactoring/overridemethods/OverrideMethodsRefactoring.java",
        "patchSetId": 12
      },
      "lineNbr": 40,
      "author": {
        "id": 598
      },
      "writtenOn": "2019-04-14T17:49:36Z",
      "side": 1,
      "message": "Remove \"package\" from this sentence",
      "revId": "1482bbb0839791ece6bcc7374d4e146c194bea20",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "29bb5408_ce683b3d",
        "filename": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/refactoring/overridemethods/VirtualMethodsASTVisitor.java",
        "patchSetId": 12
      },
      "lineNbr": 97,
      "author": {
        "id": 598
      },
      "writtenOn": "2019-04-14T17:49:36Z",
      "side": 1,
      "message": "I think we need to use the qualified name here, otherwise, you could have a class/struct with the same name but in another namespace and it would match. Here is an example where this is problematic:\n\nnamespace FIRST {\nclass Base {\npublic:\n\tvirtual ~Base() {}\n\tvirtual void baseFunc(Base* ptr) const \u003d 0;\n\tvirtual void baseFunc2(Base* ptr) const \u003d 0;\n};\n}\n\nnamespace SECOND {\nclass X: public FIRST::Base {\npublic:\n\tX();\n\tvirtual void baseFunc(Base* ptr) const {}\n};\n}\n\nnamespace THIRD {\nclass X: public FIRST::Base {\npublic:\n\tX();\n\tvirtual void baseFunc2(Base* ptr) const {}\n};\n}\n\nIn the outline view, if I select the class SECOND::X and do Override Methods, then it suggests to override baseFunc even thought it is already implemented. This is because this logic actually picked THIRD::X as the selected class (fClassNode, etc).",
      "revId": "1482bbb0839791ece6bcc7374d4e146c194bea20",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
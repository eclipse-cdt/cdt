{
  "comments": [
    {
      "key": {
        "uuid": "AABOHn//+4Q\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T15:14:03Z",
      "side": 1,
      "message": "Is this fake event only to re-enable the resume button?    If we didn\u0027t get a *running event, I don\u0027t think we should need to issue a fake *stopped event.  Instead, we should force a refresh of the enablement of the resume command.  This should be possible if we deal with the failure in the UI code (DsfResumeCommand)",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+x0\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 672
      },
      "writtenOn": "2012-05-24T17:55:30Z",
      "side": 1,
      "message": "Actually the problem here is that we do receive a ^running event, so if there is a subsequent ^error event (which is the case when an invalid breakpoint is inserted during startup), it\u0027s ignored and that\u0027s why we have fire our own suspended event.",
      "parentUuid": "AABOHn//+4Q\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+xg\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T18:14:10Z",
      "side": 1,
      "message": "I see now.  What is worst is that we also get a *running event.  So I guess there is no way to distinguish this case from a valid one.\n\nThis is a bug in GDB, but I guess we have to work around it.\n\nGDB knows the proper state of the threads even though it messed up the events, right?  What if we simply refreshed such state, instead of faking an event?  Would calling refreshThreadStates() be enough?",
      "parentUuid": "AABOHn//+x0\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+xk\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 572
      },
      "writtenOn": "2012-05-24T18:16:06Z",
      "side": 1,
      "message": "The suspend event also updates the state of the current thread.",
      "parentUuid": "AABOHn//+x0\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+w8\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T18:55:06Z",
      "side": 1,
      "message": "refreshThreadStates() also sends a fake event, for any thread that we think is running but GDB says is stopped (and vice versa) so I think it should work in this case.  I\u0027m hoping it would make the code simpler by re-using existing code.\n\nAnd we shouldn\u0027t worry about the fact we would refresh all threads, instead of just one, because this will only happen in the error case.",
      "parentUuid": "AABOHn//+xk\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+wk\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 572
      },
      "writtenOn": "2012-05-24T19:19:22Z",
      "side": 1,
      "message": "The current code uses MIErrorEvent as a stop reason which is essential - the error message is displayed as a stop reason. Would it be achieved by using refreshThreadStates()?",
      "parentUuid": "AABOHn//+w8\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+wY\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T19:27:40Z",
      "side": 1,
      "message": "I find it strange that we send a special event ourselves, to tell ourselves to display an error.  But maybe there is no way around that.  I haven\u0027t looked at the changes you made to the MIRunControlEventProcessor files, so I don\u0027t know all the details yet.\n\nLeave it as is, and we\u0027ll see once I look at the complete patch.  My current understanding is that you will update the patch to put the error handling in DsfResumeCommand et al., so I\u0027m planning on waiting until that version is ready.",
      "parentUuid": "AABOHn//+wk\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+wM\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1579,
      "author": {
        "id": 572
      },
      "writtenOn": "2012-05-24T19:32:21Z",
      "side": 1,
      "message": "Sounds good.",
      "parentUuid": "AABOHn//+wY\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+4M\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1589,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T15:14:03Z",
      "side": 1,
      "message": "When and why do we need this logic if initialization?",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+xw\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1589,
      "author": {
        "id": 672
      },
      "writtenOn": "2012-05-24T17:55:30Z",
      "side": 1,
      "message": "When an error occurs during initialization, the initialization sequence will fail and the standard \u0027startup sequence failed\u0027 error dialog will be shown - so this check is to make sure we don\u0027t display 2 popups.\n\nThe extra flag was added because there is case where we receive ^running, followed by an asynchronous ^error result, while initialization has not yet finished. In this case, initialization will complete successfully (the run command did not catch the error) so we need to always display the error popup.",
      "parentUuid": "AABOHn//+4M\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+xc\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1589,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T18:14:10Z",
      "side": 1,
      "message": "How can I reproduce this situation?",
      "parentUuid": "AABOHn//+xw\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+xE\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1589,
      "author": {
        "id": 672
      },
      "writtenOn": "2012-05-24T18:46:06Z",
      "side": 1,
      "message": "Ok, to reproduce the case where isInitialized() \u003d\u003d false, and checkIsInitialized \u003d\u003d true, a command in the initialization sequence needs to fail. In our product, we use \u0027continue\u0027 instead of \u0027run\u0027 as we need to load the code first. After setting an invalid breakpoint, the continue command fails properly, that is, it produces a single ^error record, so this method is called but the error is skipped allowing for the initialization error to be subsequently displayed.\n\nThe run command however, first produces ^running, so the run step actually completes successfully. In this case, we want to ignore the isInitialized() check.\n\nSo unfortunately unless you have a setup where you\u0027re using continue instead of run, I don\u0027t know how you can reproduce this. Does that make sense?",
      "parentUuid": "AABOHn//+xc\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+w0\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1589,
      "author": {
        "id": 457
      },
      "writtenOn": "2012-05-24T18:55:06Z",
      "side": 1,
      "message": "When connecting to a remote target we use \u0027continue\u0027 instead of run, would that cause the problem?",
      "parentUuid": "AABOHn//+xE\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "AABOHn//+ws\u003d",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/service/GDBRunControl_7_0_NS.java",
        "patchSetId": 1
      },
      "lineNbr": 1589,
      "author": {
        "id": 672
      },
      "writtenOn": "2012-05-24T18:58:14Z",
      "side": 1,
      "message": "Yes, it should do.",
      "parentUuid": "AABOHn//+w0\u003d",
      "revId": "19eb06957a8125d8de9e175b5b259c5038cd7d46",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
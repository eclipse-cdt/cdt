{
  "comments": [
    {
      "key": {
        "uuid": "c7880b39_5eb09329",
        "filename": "core/org.eclipse.cdt.ui/src/org/eclipse/cdt/internal/ui/editor/CElementHyperlinkDetector.java",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1578
      },
      "writtenOn": "2017-09-01T11:06:39Z",
      "side": 0,
      "message": "/*******************************************************************************\n * Copyright (c) 2000, 2015 QNX Software Systems and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     QNX Software Systems - Initial API and implementation\n *     IBM Corporation\n *     Markus Schorn (Wind River Systems)\n *     Sergey Prigogin (Google)\n *******************************************************************************/\npackage org.eclipse.cdt.internal.ui.editor;\n\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.IStatus;\nimport org.eclipse.core.runtime.Status;\nimport org.eclipse.jface.action.IAction;\nimport org.eclipse.jface.text.BadLocationException;\nimport org.eclipse.jface.text.IDocument;\nimport org.eclipse.jface.text.IRegion;\nimport org.eclipse.jface.text.ITextViewer;\nimport org.eclipse.jface.text.Region;\nimport org.eclipse.jface.text.TextUtilities;\nimport org.eclipse.jface.text.hyperlink.AbstractHyperlinkDetector;\nimport org.eclipse.jface.text.hyperlink.IHyperlink;\nimport org.eclipse.ui.texteditor.ITextEditor;\n\nimport org.eclipse.cdt.core.dom.ast.IASTImageLocation;\nimport org.eclipse.cdt.core.dom.ast.IASTName;\nimport org.eclipse.cdt.core.dom.ast.IASTNode;\nimport org.eclipse.cdt.core.dom.ast.IASTNodeLocation;\nimport org.eclipse.cdt.core.dom.ast.IASTNodeSelector;\nimport org.eclipse.cdt.core.dom.ast.IASTPreprocessorIncludeStatement;\nimport org.eclipse.cdt.core.dom.ast.IASTTranslationUnit;\nimport org.eclipse.cdt.core.dom.ast.IASTTypeId;\nimport org.eclipse.cdt.core.model.ICLanguageKeywords;\nimport org.eclipse.cdt.core.model.ILanguage;\nimport org.eclipse.cdt.core.model.IWorkingCopy;\nimport org.eclipse.cdt.ui.CUIPlugin;\nimport org.eclipse.cdt.ui.ICModelBasedEditor;\nimport org.eclipse.cdt.ui.text.ICPartitions;\n\nimport org.eclipse.cdt.internal.core.dom.parser.ASTQueries;\nimport org.eclipse.cdt.internal.core.dom.parser.cpp.semantics.SemanticUtil;\nimport org.eclipse.cdt.internal.core.model.ASTCache.ASTRunnable;\nimport org.eclipse.cdt.internal.formatter.scanner.Scanner;\nimport org.eclipse.cdt.internal.formatter.scanner.Token;\n\nimport org.eclipse.cdt.internal.ui.text.CWordFinder;\n\npublic class CElementHyperlinkDetector extends AbstractHyperlinkDetector {\n\n\tpublic CElementHyperlinkDetector() {\n\t}\n\n\t@Override\n\tpublic IHyperlink[] detectHyperlinks(final ITextViewer textViewer, final IRegion region, boolean canShowMultipleHyperlinks) {\n\t\tITextEditor textEditor\u003d getAdapter(ITextEditor.class);\n\t\tif (region \u003d\u003d null || !(textEditor instanceof ICModelBasedEditor))\n\t\t\treturn null;\n\n\t\tfinal IAction openAction\u003d textEditor.getAction(\"OpenDeclarations\"); //$NON-NLS-1$\n\t\tif (openAction \u003d\u003d null)\n\t\t\treturn null;\n\n\t\tIDocument document \u003d textViewer.getDocument();\n\t\tfinal IWorkingCopy workingCopy \u003d CUIPlugin.getDefault().getWorkingCopyManager().getWorkingCopy(textEditor.getEditorInput());\n\t\tif (workingCopy \u003d\u003d null) {\n\t\t\treturn null;\n\t\t}\n\n\t\tfinal IRegion[] hyperlinkRegion \u003d { null };\n\t\t// Do not wait for AST if it\u0027s not available yet. Waiting for AST would block the UI thread\n\t\t// for the duration of the parsing.\n\t\tIStatus status\u003d ASTProvider.getASTProvider().runOnAST(workingCopy, ASTProvider.WAIT_NO, null, new ASTRunnable() {\n\t\t\t@Override\n\t\t\tpublic IStatus runOnAST(ILanguage lang, IASTTranslationUnit ast) {\n\t\t\t\tif (ast \u003d\u003d null)\n\t\t\t\t\treturn Status.CANCEL_STATUS;\n\t\t\t\t\n\t\t\t\tIASTNode linkASTNode \u003d getLinkASTNode(document, ast, region);\n\t\t\t\t\n\t\t\t\tIASTNodeLocation linkLocation \u003d null;\n\t\t\t\tif (linkASTNode !\u003d null) {\n\t\t\t\t\tif (linkASTNode instanceof IASTName) {\n\t\t\t\t\t\tIASTName astName \u003d (IASTName) linkASTNode;\n\t\t\t\t\t\tIASTImageLocation imageLocation \u003d astName.getImageLocation();\n\t\t\t\t\t\tif (imageLocation !\u003d null) {\n\t\t\t\t\t\t\tlinkLocation \u003d imageLocation;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (linkLocation \u003d\u003d null) {\n\t\t\t\t\t\tlinkLocation \u003d linkASTNode.getFileLocation();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (linkLocation \u003d\u003d null) {\n\t\t\t\t\t// Consider a fallback way of finding the hyperlink\n\t\t\t\t\t// (see http://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d333050).\n\t\t\t\t\treturn Status.CANCEL_STATUS;\n\t\t\t\t}\n\n\t\t\t\thyperlinkRegion[0] \u003d new Region(linkLocation.getNodeOffset(), linkLocation.getNodeLength());\n\t\t\t\treturn Status.OK_STATUS;\n\t\t\t}\n\t\t});\n\n\t\tif (status \u003d\u003d Status.CANCEL_STATUS) {\n\t\t\t// AST was not available yet or didn\u0027t help us to find the hyperlink, try to compute\n\t\t\t// the hyperlink without it.  \n\t\t\ttry {\n\t\t\t\t// Check partition type.\n\t\t\t\tString partitionType\u003d TextUtilities.getContentType(document, ICPartitions.C_PARTITIONING, region.getOffset(), false);\n\t\t\t\tif (IDocument.DEFAULT_CONTENT_TYPE.equals(partitionType)) {\n\t\t\t\t\t// Regular code.\n\t\t\t\t\thyperlinkRegion[0] \u003d getIdentifier(document, region.getOffset(), workingCopy.getLanguage());\n\t\t\t\t} else if (ICPartitions.C_PREPROCESSOR.equals(partitionType)) {\n\t\t\t\t\t// Preprocessor directive.\n\t\t\t\t\tScanner scanner\u003d new Scanner();\n\t\t\t\t\tscanner.setSplitPreprocessor(true);\n\t\t            scanner.setSource(document.get().toCharArray());\n\t\t            scanner.setCurrentPosition(findPreprocessorDirectiveStart(document, region.getOffset()));\n\t\t            Token token \u003d scanner.nextToken();\n\t\t            if (token !\u003d null \u0026\u0026 token.getType() \u003d\u003d Token.tPREPROCESSOR_INCLUDE) {\n\t\t            \tint endPos \u003d token.getOffset() + token.getLength();\n\t\t            \t// Trim trailing whitespace.\n\t\t            \twhile (Character.isWhitespace(document.getChar(--endPos))) {\n\t\t            \t}\n\t\t            \tendPos++;\n\t\t\t            if (region.getOffset() \u003c\u003d endPos) {\n\t\t\t            \thyperlinkRegion[0] \u003d new Region(token.getOffset(), endPos - token.getOffset());\n\t\t\t            }\n\t\t            } else {\n\t\t\t\t\t\thyperlinkRegion[0] \u003d getIdentifier(document, region.getOffset(), workingCopy.getLanguage());\n\t\t            }\n\t\t\t\t}\n\t\t\t} catch (BadLocationException e) {\n\t\t\t\t// Ignore to return null.\n\t\t\t} catch (CoreException e) {\n\t\t\t\t// Ignore to return null.\n\t\t\t}\n\t\t}\n\t\tif (hyperlinkRegion[0] \u003d\u003d null)\n\t\t\treturn null;\n\t\treturn new IHyperlink[] { new CElementHyperlink(hyperlinkRegion[0], openAction) };\n\t}\n\n\tprivate static IASTNode getLinkASTNode(IDocument document, IASTTranslationUnit ast, IRegion region) {\n\t\tfinal int offset\u003d region.getOffset();\n\t\tfinal int length\u003d Math.max(1, region.getLength());\n\t\t\n\t\tfinal IASTNodeSelector nodeSelector\u003d ast.getNodeSelector(null);\n\t\tif (isOverAutoOrDecltype(document, offset)) {\n\t\t\tIASTNode node \u003d nodeSelector.findEnclosingNode(offset, length);\n\t\t\tIASTTypeId enclosingTypeId \u003d ASTQueries.findAncestorWithType(node, IASTTypeId.class);\n\t\t\tif (enclosingTypeId !\u003d null) {\n\t\t\t\treturn enclosingTypeId;\n\t\t\t}\n\t\t}\n\t\t\n\t\tIASTName selectedName\u003d nodeSelector.findEnclosingName(offset, length);\n\t\tif (selectedName !\u003d null) { // found a name\n\t\t\t// Prefer include statement over the include name\n\t\t\tif (selectedName.getParent() instanceof IASTPreprocessorIncludeStatement) {\n\t\t\t\treturn selectedName.getParent();\n\t\t\t} else {\n\t\t\t\treturn selectedName;\n\t\t\t}\n\t\t} else { \n\t\t\tfinal IASTNode implicit \u003d nodeSelector.findEnclosingImplicitName(offset, length);\n\t\t\tif (implicit !\u003d null) {\n\t\t\t\treturn implicit;\n\t\t\t} else {\n\t\t\t\t// Search for include statement\n\t\t\t\tfinal IASTNode cand\u003d nodeSelector.findEnclosingNode(offset, length);\n\t\t\t\tif (cand instanceof IASTPreprocessorIncludeStatement) {\n\t\t\t\t\treturn cand;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\t\n\tprivate static boolean isOverAutoOrDecltype(IDocument document, int offset) {\n\t\ttry {\n\t\t\tIRegion wordRegion \u003d CWordFinder.findWord(document, offset);\n\t\t\tif (wordRegion !\u003d null \u0026\u0026 wordRegion.getLength() \u003e 0) {\n\t\t\t\tString word \u003d document.get(wordRegion.getOffset(), wordRegion.getLength());\n\t\t\t\treturn SemanticUtil.isAutoOrDecltype(word);\n\t\t\t}\n\t\t} catch (BadLocationException e) {\n\t\t\t// Fall through and return false.\n\t\t}\n\t\treturn false;\n\t}\n\t\n\t/**\n\t * Returns the identifier at the given offset, or {@code null} if the there is no identifier\n\t * at the offset.\n\t */\n\tprivate static IRegion getIdentifier(IDocument document, int offset, ILanguage language) throws BadLocationException {\n\t\tIRegion wordRegion\u003d CWordFinder.findWord(document, offset);\n\t\tif (wordRegion !\u003d null \u0026\u0026 wordRegion.getLength() \u003e 0) {\n\t\t\tString word \u003d document.get(wordRegion.getOffset(), wordRegion.getLength());\n\t\t\tif (!Character.isDigit(word.charAt(0))) {\n\t\t\t\tif (SemanticUtil.isAutoOrDecltype(word) || !isLanguageKeyword(language, word)) {\n\t\t\t\t\treturn wordRegion;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\tprivate static boolean isLanguageKeyword(ILanguage lang, String word) {\n\t\tICLanguageKeywords keywords\u003d lang.getAdapter(ICLanguageKeywords.class);\n\t\tif (keywords !\u003d null) {\n\t\t\tfor (String keyword : keywords.getKeywords()) {\n\t\t\t\tif (keyword.equals(word))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (String type : keywords.getBuiltinTypes()) {\n\t\t\t\tif (type.equals(word))\n\t\t\t\t\treturn true;\n\t\t\t}\n\t\t\tfor (String keyword : keywords.getPreprocessorKeywords()) {\n\t\t\t\tif (keyword.charAt(0) \u003d\u003d \u0027#\u0027 \u0026\u0026 keyword.length() \u003d\u003d word.length() + 1 \u0026\u0026\n\t\t\t\t\t\tkeyword.regionMatches(1, word, 0, word.length())) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\t/**\n\t * Finds beginning of a preprocessor directive.\n\t */\n\tprivate static int findPreprocessorDirectiveStart(IDocument document, int offset) throws BadLocationException {\n\t\twhile (true) {\n\t\t\tIRegion lineRegion \u003d document.getLineInformationOfOffset(offset);\n\t\t\tint lineOffset \u003d lineRegion.getOffset();\n\t\t\tif (lineOffset \u003d\u003d 0)\n\t\t\t\treturn lineOffset;\n\t\t\tint lineEnd \u003d lineOffset + lineRegion.getLength();\n\t\t\tfor (offset \u003d lineOffset; offset \u003c lineEnd \u0026\u0026 Character.isWhitespace(document.getChar(offset)); offset++) {\n\t\t\t}\n\t\t\tif (offset \u003c document.getLength() \u0026\u0026 document.getChar(offset) \u003d\u003d \u0027#\u0027) {\n\t\t\t\treturn lineOffset;\n\t\t\t}\n\t\t\t// The line doesn\u0027t start with #, try previous line.\n\t\t\toffset \u003d lineOffset - 1;\n\t\t}\n\t}\n}",
      "revId": "33a7f1e53349bdef9c5bc45926bd8c6410630248",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
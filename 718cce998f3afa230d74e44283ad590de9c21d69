{
  "comments": [
    {
      "key": {
        "uuid": "c73e4bec_39eb3fa0",
        "filename": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/core/dom/ast/cpp/ICPPTypeTraitType.java",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 577
      },
      "writtenOn": "2013-08-30T01:50:12Z",
      "side": 1,
      "message": "Can we use TypeOfDependentExpression in combination with EvalUnaryTypeID instead?",
      "revId": "718cce998f3afa230d74e44283ad590de9c21d69",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c73e4bec_d9185b37",
        "filename": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/core/dom/ast/cpp/ICPPTypeTraitType.java",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 973
      },
      "writtenOn": "2013-08-30T02:01:00Z",
      "side": 1,
      "message": "I don\u0027t think so. An evaluation comes from an expression (gramatically) and has a value (semantically). This kind of type trait, on the other hand, comes from a type-id (more precisely a decl-spec) grammatically, and doesn\u0027t have a value, only a type.",
      "parentUuid": "c73e4bec_39eb3fa0",
      "revId": "718cce998f3afa230d74e44283ad590de9c21d69",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c73e4bec_9937f362",
        "filename": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/core/dom/ast/cpp/ICPPTypeTraitType.java",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 577
      },
      "writtenOn": "2013-08-30T02:27:54Z",
      "side": 1,
      "message": "Hmm. __underlying_type(T) appears to be very similar to typeof(T), which is modeled using IASTTypeIdExpression and EvalUnaryTypeID. Am I missing something?",
      "parentUuid": "c73e4bec_d9185b37",
      "revId": "718cce998f3afa230d74e44283ad590de9c21d69",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c73e4bec_9475faa4",
        "filename": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/core/dom/ast/cpp/ICPPTypeTraitType.java",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 973
      },
      "writtenOn": "2013-08-30T03:24:24Z",
      "side": 1,
      "message": "Interesting; I didn\u0027t know that there was such a thing as typeof(T) and that we modelled it. I agree that it is very similar to __underlying_type(T). I think it\u0027s fairly strange to model it as an IASTExpression, though. I would expect an expression to have a value, and to be usable in expression contexts, for example \"\u003ce\u003e\" in \"Type var \u003d \u003ce\u003e;\". typeof(T) doesn\u0027t have a value and it\u0027s not usable in such contexts, and I believe it\u0027s the only IASTExpression which is like that.\n\nValue.applyUnaryTypeIdOperator() currently has a comment saying \"TODO(sprigogin): Implement\" for the \u0027op_typeof\u0027 case. What implement did you have in mind for it? What implementation would you suggest for the __underlying_type case if we model it the same way? To me these questions don\u0027t even make sense, because typeof(T) and __underlying_type(T), unlike sizeof(T) or any of __is_XXX(T) or __has_XXX(T) traits, don\u0027t have values.",
      "parentUuid": "c73e4bec_9937f362",
      "revId": "718cce998f3afa230d74e44283ad590de9c21d69",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "c73e4bec_e258f7d1",
        "filename": "core/org.eclipse.cdt.core/parser/org/eclipse/cdt/core/dom/ast/cpp/ICPPTypeTraitType.java",
        "patchSetId": 1
      },
      "lineNbr": 27,
      "author": {
        "id": 577
      },
      "writtenOn": "2013-08-30T17:42:04Z",
      "side": 1,
      "message": "I always thought of evaluations as representing value/type pairs. Some evaluations never produce meaningful values and always have to be wrapped in TypeOfDependentExpression. Having said that, I agree that for type expressions this approach is rather clumsy. If we are to change how we model type expressions, we should use an approach that can be applied to all type expressions, not just to __underlying_type(T). It seems that the name of this interface is too specialized to look natural in a wider context. What would you think of calling it ICPPUnaryTypeExpression?",
      "parentUuid": "c73e4bec_9475faa4",
      "revId": "718cce998f3afa230d74e44283ad590de9c21d69",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
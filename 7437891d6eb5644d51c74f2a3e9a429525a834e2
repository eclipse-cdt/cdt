{
  "comments": [
    {
      "key": {
        "uuid": "0756a345_468edc3e",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 482
      },
      "writtenOn": "2014-04-08T18:35:47Z",
      "side": 1,
      "message": "I think the calculation of endAddress will not be correct for addessable sizes larger than one. \n  \nThe confusing part is that \n  addressSize is received in addressable units (formal definition of Byte)\n   i.e. the size of a pointer in char-size units, \n\n   addressableSize will be the size of a char-unit in octets.\n\nSo in order to find out the address size in octets we need to multiply. i.e. \n\naddressSize (in octets) \u003d addressSize (addessable units) * addressableSize (in octets per addressable units)\n\n(using the word octets here on purpose to avoid confusion with the word byte :-))\n\nSo I think the line above should then be:\nBigInteger endAddress \u003d BigInteger.ONE.shiftLeft(addressSize*addressableSize*8).subtract(BigInteger.ONE);",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_4cc1dbfa",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 1291
      },
      "writtenOn": "2014-04-09T08:14:42Z",
      "side": 1,
      "message": "Actually the maximum address calculation should not take  in account addressableSize at all. As the code is not ought to compute length but the highest value that a pointer can have.\nI will submit a new patch that removes unnecessary faulty operations.",
      "parentUuid": "0756a345_468edc3e",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_20174b52",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 482
      },
      "writtenOn": "2014-04-09T11:14:02Z",
      "side": 1,
      "message": "The thing is that addressSize is not in octets but in \"units that are the size of a char\", so for a 16 bit per char systems this means a value of 1 does not represent an octet,\n  by using the 2 octets per char unit (addressable size) we can determine the size of an address in octets.\n\n   So you need to multiply by addressable size to obtain octets and then multiply by 8 to get bits :-)\n\n\nyou can see this used in several places e.g. \nMIMemory#updateMemoryCache\nthe word_count is the amount of addressable units or \"words\", the word_size is the addressable size in octets.\n\nyou can see the calculation of octets in local variable \"count\"",
      "parentUuid": "0756a345_4cc1dbfa",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
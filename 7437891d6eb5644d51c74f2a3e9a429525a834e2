{
  "comments": [
    {
      "key": {
        "uuid": "0756a345_468edc3e",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 482
      },
      "writtenOn": "2014-04-08T18:35:47Z",
      "side": 1,
      "message": "I think the calculation of endAddress will not be correct for addessable sizes larger than one. \n  \nThe confusing part is that \n  addressSize is received in addressable units (formal definition of Byte)\n   i.e. the size of a pointer in char-size units, \n\n   addressableSize will be the size of a char-unit in octets.\n\nSo in order to find out the address size in octets we need to multiply. i.e. \n\naddressSize (in octets) \u003d addressSize (addessable units) * addressableSize (in octets per addressable units)\n\n(using the word octets here on purpose to avoid confusion with the word byte :-))\n\nSo I think the line above should then be:\nBigInteger endAddress \u003d BigInteger.ONE.shiftLeft(addressSize*addressableSize*8).subtract(BigInteger.ONE);",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_4cc1dbfa",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 1291
      },
      "writtenOn": "2014-04-09T08:14:42Z",
      "side": 1,
      "message": "Actually the maximum address calculation should not take  in account addressableSize at all. As the code is not ought to compute length but the highest value that a pointer can have.\nI will submit a new patch that removes unnecessary faulty operations.",
      "parentUuid": "0756a345_468edc3e",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_20174b52",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 482
      },
      "writtenOn": "2014-04-09T11:14:02Z",
      "side": 1,
      "message": "The thing is that addressSize is not in octets but in \"units that are the size of a char\", so for a 16 bit per char systems this means a value of 1 does not represent an octet,\n  by using the 2 octets per char unit (addressable size) we can determine the size of an address in octets.\n\n   So you need to multiply by addressable size to obtain octets and then multiply by 8 to get bits :-)\n\n\nyou can see this used in several places e.g. \nMIMemory#updateMemoryCache\nthe word_count is the amount of addressable units or \"words\", the word_size is the addressable size in octets.\n\nyou can see the calculation of octets in local variable \"count\"",
      "parentUuid": "0756a345_4cc1dbfa",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_e0a71307",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 1291
      },
      "writtenOn": "2014-04-09T16:11:30Z",
      "side": 1,
      "message": "This check is about learning the maximum address of a *unit*. \n\nI think the statement comment is misleading. It should be \"check for address exceeding maximum value\". I will update accordingly.",
      "parentUuid": "0756a345_20174b52",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_36b67126",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 482
      },
      "writtenOn": "2014-04-09T17:55:01Z",
      "side": 1,
      "message": "I think this confusion comes from an incorrect use of the word byte all over, \nand making the java doc clear enough may not actually be possible as the word byte is used in many legacy code as octet.\n\nHere goes an example of what you will get from a 32 bit address system with a minimum addressable size of 16 bits (16 bit char)\n\n    addressSize: 2       (addressable units)\n    addressableSize: 2   (2 octets needed to represent one character)\n\nif we apply the java line as per patchset 3.\n\tBigInteger endAddress \u003d BigInteger.ONE.shiftLeft(addressSize*8).subtract(BigInteger.ONE);\n\n\twill be shifting only 16 bits to the left instead of 32",
      "parentUuid": "0756a345_e0a71307",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0756a345_54d03df4",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/internal/memory/GdbMemoryBlockRetrieval.java",
        "patchSetId": 1
      },
      "lineNbr": 182,
      "author": {
        "id": 1291
      },
      "writtenOn": "2014-04-10T16:35:41Z",
      "side": 1,
      "message": "Thank you for your example.This is a worthfull discussion to be moved to main comment area.",
      "parentUuid": "0756a345_36b67126",
      "revId": "7437891d6eb5644d51c74f2a3e9a429525a834e2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
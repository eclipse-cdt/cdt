{
  "comments": [
    {
      "key": {
        "uuid": "01091537_85b73456",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/FinalLaunchSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 654,
      "author": {
        "id": 27769
      },
      "writtenOn": "2020-11-09T01:28:23Z",
      "side": 1,
      "message": "I think this should be gdbjtag aka hardware debug specific and not added to the general GDB case which does not need it. Unless there is an example of it failing. The reason the gdbjtag one has this problem is because of the types of commands issued in its launch sequence.\n\nIf it should remain here, it probably should go before the DataModelInitializedEvent.\n\nEither way, with the refresh here many tests are broken that rely on (too?) deep knowledge of the implementation and how many events are expected through the system.\n\n\u003cSomewhat OT\u003eWhen I first went to implement this I came to the conclusion that DataModelInitializedEvent itself should probably do what we are discussing here - i.e. until DataModelInitializedEvent is received nothing should start rendering as the data model was not initialized yet. While some places in DSF (such as GDBFocusSynchronizer) use it like that, most other (in particular UI places like LaunchRootVMNode) use it simply as an indicator that the Debug view tree should be expanded and selected.\u003c/\u003e",
      "range": {
        "startLine": 654,
        "startChar": 0,
        "endLine": 654,
        "endChar": 2
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ba4682de_22528a7c",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/FinalLaunchSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 654,
      "author": {
        "id": 5071
      },
      "writtenOn": "2020-11-17T20:36:11Z",
      "side": 1,
      "message": "Yes, I was actually trying to follow what the DataModelInitializedEvent was doing and if that could not be used, but then I thought of the use case where a 3rd party vendor will add some other UI elements that for example resets the target. In that case, it would be a bit weird to send another DataModelInitializedEvent, so I think both are needed.\n\nThe reason why I placed it here is that I though that it could be useful for non-gdbjtag sessions too, but I can move it, no problem!\n\nDo you know any good way to fix all the failing test cases in a way that they are still reliable?\nThe builds have been removed from Jenkins, so I need to push something new to have the report to look at.",
      "parentUuid": "01091537_85b73456",
      "range": {
        "startLine": 654,
        "startChar": 0,
        "endLine": 654,
        "endChar": 2
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8a6b4665_b7b464cb",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/FinalLaunchSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 657,
      "author": {
        "id": 5071
      },
      "writtenOn": "2020-11-08T22:09:30Z",
      "side": 1,
      "message": "I cannot find a way to query the target if it\u0027s in suspended state or running state here.\nAt the same time, I cannot see any harm in doing a flush here since it\u0027s done during the launch of the debug session and not now and then during the debug session.\nWould it be worth the extra complexity to check the target state?",
      "range": {
        "startLine": 654,
        "startChar": 0,
        "endLine": 657,
        "endChar": 5
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7ec625bf_84835f96",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/FinalLaunchSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 657,
      "author": {
        "id": 27769
      },
      "writtenOn": "2020-11-09T01:14:10Z",
      "side": 1,
      "message": "Not worth the extra complexity.\n\nI think it is essentially a No-op to do the refresh when target is running. The flush and refresh set states that are set anyways when the target will eventually suspend.\n\nIn addition, it is non-trivial to find out if target is suspended/running as you need to first query all running containers and then ask each container.",
      "parentUuid": "8a6b4665_b7b464cb",
      "range": {
        "startLine": 654,
        "startChar": 0,
        "endLine": 657,
        "endChar": 5
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5707600a_05a631f8",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/FinalLaunchSequence.java",
        "patchSetId": 1
      },
      "lineNbr": 657,
      "author": {
        "id": 5071
      },
      "writtenOn": "2020-11-17T20:36:11Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "7ec625bf_84835f96",
      "range": {
        "startLine": 654,
        "startChar": 0,
        "endLine": 657,
        "endChar": 5
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "8b6cef89_b168b942",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/mi/service/command/AbstractMIControl.java",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 5071
      },
      "writtenOn": "2020-11-08T22:09:30Z",
      "side": 1,
      "message": "Is RefreshAllDMEvent okay here or should it be align with the interface and be called something like \u0027CommandControlRefreshAllDMEvent\u0027?",
      "range": {
        "startLine": 158,
        "startChar": 22,
        "endLine": 158,
        "endChar": 39
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bd798333_75e2a9bd",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/mi/service/command/AbstractMIControl.java",
        "patchSetId": 1
      },
      "lineNbr": 158,
      "author": {
        "id": 27769
      },
      "writtenOn": "2020-11-09T01:14:10Z",
      "side": 1,
      "message": "This private class name is fine.\n\nIf anything there can be a discussion about the name of the public interface. The interfaces under IDMEvent in DSF are about 50/50 in terms of including the enclosing class/interface name in the name of the interface. I am fine either way with the interface name, but in general including the enclosing class/interface name in the name of another class/interface seems a little redundant as someone can write ICommandControlService.IRefreshAllDMEvent in a bit of code that there is concern about differentiating.",
      "parentUuid": "8b6cef89_b168b942",
      "range": {
        "startLine": 158,
        "startChar": 22,
        "endLine": 158,
        "endChar": 39
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ac9521a7_5b2ccad5",
        "filename": "dsf/org.eclipse.cdt.dsf/src/org/eclipse/cdt/dsf/debug/service/command/ICommandControlService.java",
        "patchSetId": 1
      },
      "lineNbr": 87,
      "author": {
        "id": 5071
      },
      "writtenOn": "2020-11-08T22:09:30Z",
      "side": 1,
      "message": "Alexander had some concerns regarding if this should be part of ICommandControlService in a previous gerrit. Should I leave it here or create some new interface where it\u0027s added?\nIf I should create a new one, what should it be named?\nDo we need a completlly different service for this function too? Overkill?",
      "range": {
        "startLine": 87,
        "startChar": 21,
        "endLine": 87,
        "endChar": 45
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c3d23ab1_6b7c00af",
        "filename": "dsf/org.eclipse.cdt.dsf/src/org/eclipse/cdt/dsf/debug/service/command/ICommandControlService.java",
        "patchSetId": 1
      },
      "lineNbr": 87,
      "author": {
        "id": 27769
      },
      "writtenOn": "2020-11-09T01:14:10Z",
      "side": 1,
      "message": "There \"where flushAllCachesAndRefresh and ICommandControlRefreshAllDMEvent should live\" question has this answer: the refresh functionality is useful to all kinds of backends, not just MI or GDB ones.\n\nSince the existing services in the DSF layer are all quite specific (e.g. breakpoints, memory, processes) the logical place to me is to have it in command control. \n\nA separate service is overkill.\n\nIf there is question about whether it should be in the DSF layer - the other reasonable possibilities are IMIBackend in the DSF-MI layer and IGDBBackend in the DSF-GDB layer.",
      "parentUuid": "ac9521a7_5b2ccad5",
      "range": {
        "startLine": 87,
        "startChar": 21,
        "endLine": 87,
        "endChar": 45
      },
      "revId": "7c89f7bbcbdd0aae67303f235b6786522082c1a2",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": true
    }
  ]
}
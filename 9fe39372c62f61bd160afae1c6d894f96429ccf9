{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "72424a2d_cd0d8f8b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 164318
      },
      "writtenOn": "2022-05-23T09:42:26Z",
      "side": 1,
      "message": "Added test, and re-worked so that a marshallable ICPPExecution is created (to fix fallout from adding test...).\n",
      "revId": "9fe39372c62f61bd160afae1c6d894f96429ccf9",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7bb43bff_9a6ca593",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 38406
      },
      "writtenOn": "2022-05-23T12:51:46Z",
      "side": 1,
      "message": "LGTM. \n\nIt might also make sense to marshall/unmarshall the execution in ExecBuiltin (looks like many of the other ICPPExecution classes do), but I\u0027m not sure about that.",
      "revId": "9fe39372c62f61bd160afae1c6d894f96429ccf9",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "05cb42c3_ec12bf82",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 27769
      },
      "writtenOn": "2022-05-24T14:28:20Z",
      "side": 1,
      "message": "Thank you Dominic and Morty for the reviews.\n\nI have tried to learn this code and I am pretty close to submitting it. However I tried adding some additional tests to try to understand the code and I found one case where GCC and CDT behave differently. I don\u0027t know which bit of code is responsible for narrowing the value passed in, but in this case I provide a constant of type \"long int\" and GCC converts that to 0, leading ffs to return 0, but CDT preserves the long int and returns 36.\n\nThis is the test:\n\n\n\t// constexpr int x \u003d __builtin_ffs(0x800000000);\n\tpublic void testBuiltinFfsOverflow() throws Exception {\n\t\tassertEvaluationEquals(0); // CDT is returning 36 here\n\t}\n\nAnd this is the warning GCC provides:\n\na.c:6:80: warning: overflow in conversion from ‘long int’ to ‘int’ changes value from ‘34359738368’ to ‘0’ [-Woverflow]\n\n@Davin - do you know if the above is an error in your new code or elsewhere in CDT just exposed in your code?\n\nThese are the additional tests that I wrote to cover the variants of ffs and the limits of inputs.\n\n\n\t// constexpr int x \u003d __builtin_ffs(0);\n\tpublic void testBuiltinFfsZero() throws Exception {\n\t\tassertEvaluationEquals(0);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffsl(0);\n\tpublic void testBuiltinFfslZero() throws Exception {\n\t\tassertEvaluationEquals(0);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffsll(0);\n\tpublic void testBuiltinFfsllZero() throws Exception {\n\t\tassertEvaluationEquals(0);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffs(0x80000000);\n\tpublic void testBuiltinFfsMax() throws Exception {\n\t\tassertEvaluationEquals(32);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffsl(0x8000000000000000);\n\tpublic void testBuiltinFfslMax() throws Exception {\n\t\tassertEvaluationEquals(64);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffsll(0x8000000000000000);\n\tpublic void testBuiltinFfsllMax() throws Exception {\n\t\tassertEvaluationEquals(64);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffs(0x800000000);\n\tpublic void testBuiltinFfsOverflow() throws Exception {\n\t\tassertEvaluationEquals(0);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffsl(0x80000000000000000);\n\tpublic void testBuiltinFfslOverflow() throws Exception {\n\t\tassertEvaluationEquals(0);\n\t}\n\n\t// constexpr int x \u003d __builtin_ffsll(0x80000000000000000);\n\tpublic void testBuiltinFfsllOverflow() throws Exception {\n\t\tassertEvaluationEquals(0);\n\t}",
      "revId": "9fe39372c62f61bd160afae1c6d894f96429ccf9",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "704273db_61471c9a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 164318
      },
      "writtenOn": "2022-05-25T12:07:14Z",
      "side": 1,
      "message": "@Jonah - this is a little complicated. We could separate out builtin_ffs/_ffsl/_ffsll handling and have them narrow the argument accordingly which could make your test case pass, but one issue is the question of how to narrow accordingly - i.e. what size can we assume int, long, and long long actually are? On Windows I believe \"long int\" is still 32 bits whereas on linux it is 64, unless compiling for 32-bit environment where it is 32.\n\nI do note that CDT doesn\u0027t seem to handle narrowing very well generally, eg: https://godbolt.org/z/nsE418jde\n\nI think ultimately to fix you\u0027d want some way of reliably and correctly narrowing and I\u0027m not sure that exists in CDT currently. (If it does though I\u0027m happy to try and make use of it, just need a pointer).",
      "parentUuid": "05cb42c3_ec12bf82",
      "revId": "9fe39372c62f61bd160afae1c6d894f96429ccf9",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "24c87e36_8024c692",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 27769
      },
      "writtenOn": "2022-05-25T15:43:17Z",
      "side": 1,
      "message": "I don\u0027t know where/if it exists. As this is the overflow case in constants only I recommend we go with the change as you have it now.",
      "parentUuid": "704273db_61471c9a",
      "revId": "9fe39372c62f61bd160afae1c6d894f96429ccf9",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31"
    }
  ]
}
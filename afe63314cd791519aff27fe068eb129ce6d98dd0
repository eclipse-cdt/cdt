{
  "comments": [
    {
      "key": {
        "uuid": "a7c23755_7a9acac6",
        "filename": "debug/org.eclipse.cdt.debug.ui/src/org/eclipse/cdt/debug/internal/ui/actions/PinDebugContextActionDelegate.java",
        "patchSetId": 2
      },
      "lineNbr": 145,
      "author": {
        "id": 457
      },
      "writtenOn": "2017-01-25T18:25:46Z",
      "side": 1,
      "message": "Is there a case where partClosed() will be called here but the dispose()\nmethod will not be called directly?\nIf not, then why do we need this IPartListener2 and not rely on dispose()\nall the time?\nIf so, then calling dispose() ourselves does more cleanup than we used to.",
      "revId": "afe63314cd791519aff27fe068eb129ce6d98dd0",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_b01561cc",
        "filename": "debug/org.eclipse.cdt.debug.ui/src/org/eclipse/cdt/debug/internal/ui/actions/PinDebugContextActionDelegate.java",
        "patchSetId": 2
      },
      "lineNbr": 145,
      "author": {
        "id": 7168
      },
      "writtenOn": "2017-01-26T11:22:35Z",
      "side": 1,
      "message": "\"Is there a case where partClosed() will be called here but the dispose() method will not be called directly?\"\n\nI don\u0027t think so, because the lifecycle of the action delegate is bound to the lifecycle of the view part. I wish this was clearly document in code, or even enforced by API. Also, it\u0027s unclear at a glance which one gets called first. From testing it, dispose gets called first, which causes partClosed to not be called because IPartListener2 is removed.\n\nBut, it\u0027s something that might change in the future. Imagine PinDebugContextActionDelegate gets refactored to use the commands/handlers mechanism instead. Then maybe partClosed would get called first. Or dispose not called at all?\n\nNote that in this particular case dispose() is re-entrant, if it gets called a second time I think it will simply have no effect. This way I reckon we are protected from having to care if both of dispose and partClose get called or if just one.",
      "parentUuid": "a7c23755_7a9acac6",
      "revId": "afe63314cd791519aff27fe068eb129ce6d98dd0",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_2b43a616",
        "filename": "debug/org.eclipse.cdt.debug.ui/src/org/eclipse/cdt/debug/internal/ui/actions/PinDebugContextActionDelegate.java",
        "patchSetId": 2
      },
      "lineNbr": 145,
      "author": {
        "id": 457
      },
      "writtenOn": "2017-01-26T16:21:35Z",
      "side": 1,
      "message": "Yes, dispose is re-entrant, so that is safe.\nHowever, I am concerned that partClosed() now calls: \n\t\tDebugUITools.removePartDebugContextListener(fPart.getSite(), this);\n\t\tfPart.getSite().getWorkbenchWindow().getPartService().removePartListener(fPartListener);\nwhich it didn\u0027t call before.\nIf there could be a scenario where partClosed() is called but dispose() is not,\nthen partOpened() could be called and everything would continue to work properly with the previous code;\nhowever, with the new code, things won\u0027t work anymore.\nTherefore, I sugggest not calling dispose() from partClosed() but instead to leave\npartClosed() as before, and make the modificationly to dispose() and put a comment\nthat partClosed() may not get called due to a race, so we uncheck the pin button directly\nin dispose() also.",
      "revId": "afe63314cd791519aff27fe068eb129ce6d98dd0",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
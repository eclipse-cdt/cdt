//!Param const and reference and pointer
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
class X {
public:
	bool /*$*/a(int = 100)/*$$*/ const;
};

//=
class X {
public:
	bool a(int = 100) const;
};

inline bool X::a(int int1) const {
}


//!Param const and reference and pointer two params
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
class X {
public:
	bool /*$*/xy(int, int i)/*$$*/ const;
};

//=
class X {
public:
	bool xy(int, int i) const;
};

inline bool X::xy(int int1, int i) const {
}


//!Test if TemplateMethod stays in header
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
template<class T>
class A {
public:
	/*$*/void test();/*$$*/
};

//=
template<class T>
class A {
public:
	void test();
};

template<class T>
inline void A<T>::test() {
}


//@A.cpp
#include "A.h"

//=
#include "A.h"

//!class template member functions
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
template<class T>
class A {
public:
    A();
    /*$*/void test();/*$$*/
};

template<class T>
A<T>::A() {
}

//=
template<class T>
class A {
public:
    A();
    void test();
};

template<class T>
A<T>::A() {
}

template<class T>
inline void A<T>::test() {
}


//!member class
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h

class Demo {
	class SubClass {
		/*$*/void test();/*$$*/
	};
};


//@A.cpp
#include "A.h"

//=
#include "A.h"

void Demo::SubClass::test() {
}
//!Method declared in otherwise empty class without cpp file
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
class A {
public:
	/*$*/void test();/*$$*/
};

//=
class A {
public:
	void test();
};

inline void A::test() {
}


//!Method declared in otherwise empty class
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
class A {
public:
	/*$*/void test();/*$$*/
};

//=
class A {
public:
	void test();
};

//@A.cpp

//=

void A::test() {
}
//!Implement in existing namespace
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
namespace Namespace {

class ClassInNamespace {
public:
	int test();
	/*$*/void test2();/*$$*/
};

}

//@A.cpp
#include "A.h"

namespace Namespace {

int ClassInNamespace::test() {
	return 5;
}

}
//=
#include "A.h"

namespace Namespace {

int ClassInNamespace::test() {
	return 5;
}

void ClassInNamespace::test2() {
}

}
//!virtual method in the middle of con/destructor, without parameters and void return value
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
#ifndef A_H_
#define A_H_

class A {
public:
	A();
	/*$*/virtual void foo();/*$$*/
	~A();
};

#endif /*A_H_*/
//@A.cpp
#include "A.h"

A::A() {
}

A::~A() {
}

//=
#include "A.h"

A::A() {
}

void A::foo() {
}

A::~A() {
}

//!Implement a function at start of source file
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
/*$*/void function();/*$$*/
void function_with_impl();
//@A.cpp
void function_with_impl() {
}
//=
void function() {
}

void function_with_impl() {
}
//!Method at end, without parameters and void return value
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
#ifndef A_H_
#define A_H_

class A {
public:
	A();
	/*$*/void foo();/*$$*/
};

#endif /*A_H_*/
//@A.cpp
#include "A.h"

A::A() {
}

//=
#include "A.h"

A::A() {
}

void A::foo() {
}


//!Method at beginning, without parameters, void return value and const
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
#ifndef A_H_
#define A_H_

class A {
public:
	/*$*/void foo() const;/*$$*/
	A();
};

#endif /*A_H_*/
//@A.cpp
#include "A.h"

A::A() {
}

//=
#include "A.h"

void A::foo() const {
}

A::A() {
}

//!Method with int return value
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
#ifndef A_H_
#define A_H_

class A {
public:
	A();
	/*$*/int foo();/*$$*/
};

#endif /*A_H_*/
//@A.cpp
#include "A.h"

A::A() {
}

//=
#include "A.h"

A::A() {
}

int A::foo() {
}


//!Method with two int parameters
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
#ifndef A_H_
#define A_H_

class A {
public:
	A();
	/*$*/int foo(int param1, int param2);/*$$*/
};

#endif /*A_H_*/
//@A.cpp
#include "A.h"

A::A() {
}

//=
#include "A.h"

A::A() {
}

int A::foo(int param1, int param2) {
}


//!Method defined in header
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
class A {
public:
	A();
	/*$*/void test();/*$$*/
};

A::A() {
}

//=
class A {
public:
	A();
	void test();
};

A::A() {
}

inline void A::test() {
}


//!Implement a function at end of source file
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
void function_with_impl();
/*$*/void function();/*$$*/
//@A.cpp
void function_with_impl() {
}
//=
void function_with_impl() {
}

void function() {
}

//!Implement with namespace
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
namespace Namespace  {

class ClassInNamespace {
public:
	int other_test();
	/*$*/void test();/*$$*/
};

}

//@A.cpp
#include "A.h"
void Namespace::ClassInNamespace::other_test() {
}
//=
#include "A.h"
void Namespace::ClassInNamespace::other_test() {
}

void Namespace::ClassInNamespace::test() {
}

//!Implement function within namespace
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
namespace OuterSpace {
namespace Namespace {

int test();
/*$*/int test2();/*$$*/

}
}

//@A.cpp
#include "A.h"
namespace OuterSpace {

int Namespace::test() {	
}

}
//=
#include "A.h"
namespace OuterSpace {

int Namespace::test() {	
}

int Namespace::test2() {
}

}
//!Implement function within namespaces
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
namespace OuterSpace {
namespace Namespace	{

int test();
/*$*/int test2();/*$$*/

}
}

//@A.cpp
#include "A.h"
namespace OuterSpace {
namespace Namespace {

int test() {	
}

}
}
//=
#include "A.h"
namespace OuterSpace {
namespace Namespace {

int test() {	
}

int test2() {
}

}
}
//!class template member functions with multiple templates
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h
template<class T, class U>
class A {
public:
    A();
    /*$*/void test();/*$$*/
};

template<class T, class U>
A<T,U>::A() {
}

//=
template<class T, class U>
class A {
public:
    A();
    void test();
};

template<class T, class U>
A<T,U>::A() {
}

template<class T, class U>
inline void A<T, U>::test() {
}


//!with default parameters
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h

class Class {
public:
	/*$*/void test(int param1, int param2 = 5, int param3 = 10);/*$$*/
};


//@A.cpp
#include "A.h"

//=
#include "A.h"

void Class::test(int param1, int param2, int param3) {
}
//!static method
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h

class Class {
public:
	/*$*/static void test();/*$$*/
};


//@A.cpp
#include "A.h"

//=
#include "A.h"

void Class::test() {
}
//! Bug 238253 Pointer refence of the return value lost
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h

class TestClass {
public:
	/*$*/int* get(char* val);/*$$*/
};


//@A.cpp
#include "A.h"

//=
#include "A.h"

int* TestClass::get(char* val) {
}
//! Bug 238554 void parameters
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h

class Test {
public:
	/*$*/void doNothing(void);/*$$*/
};


//@A.cpp
#include "A.h"

//=
#include "A.h"

void Test::doNothing(void) {
}
//! Bug 282989 Refactor->Implement method option doesn't qualify the name in the method definition with a fully qualified container class name
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=TestClass.h
infos=1
//@TestClass.h
#ifndef TESTCLASS_H_
#define TESTCLASS_H_

namespace nspace {

class TestClass {
	void /*$*/testMethod()/*$$*/;
};

}

#endif /* TESTCLASS_H_ */

//=
#ifndef TESTCLASS_H_
#define TESTCLASS_H_

namespace nspace {

class TestClass {
	void testMethod();
};

}

inline void nspace::TestClass::testMethod() {
}


#endif /* TESTCLASS_H_ */

//!Bug 290110 Source-> Implement Method
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h
#ifndef A_H_
#define A_H_

namespace n1 {
namespace n2 {

class A {
public:
	A();
	~A();
	void testmethod(int x);

protected:
	class B {
	public:
		void /*$*/testmethod2()/*$$*/;
	};
};

}
}


#endif /* A_H_ */
//@A.cpp
#include "A.h"

namespace n1 {
namespace n2 {

A::A() {
}

A::~A() {
}

}
}

//=
#include "A.h"

namespace n1 {
namespace n2 {

A::A() {
}

A::~A() {
}

}
}

void n1::n2::A::B::testmethod2() {
}


//!Bug 337040 - Insert definition in empty implementation file (.cxx)
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
//@A.h

class TestClass {
public:
	/*$*/void foo();/*$$*/
};


//@A.cxx

//=

void TestClass::foo() {
}
//!Bug 355006 - NPE implementing template function
//#org.eclipse.cdt.ui.tests.refactoring.implementmethod.ImplementMethodRefactoringTest
//@.config
filename=A.h
infos=1
//@A.h

/*$*/template<typename T>
void func(T&);/*$$*/
//=

template<typename T>
void func(T&);

template<typename T>
inline void func(T&) {
}


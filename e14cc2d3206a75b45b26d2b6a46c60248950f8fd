{
  "comments": [
    {
      "key": {
        "uuid": "a7c23755_03e675d4",
        "filename": "cross/org.eclipse.cdt.launch.remote/src/org/eclipse/cdt/launch/remote/RemoteHelper.java",
        "patchSetId": 3
      },
      "lineNbr": 37,
      "author": {
        "id": 938
      },
      "writtenOn": "2017-02-21T17:40:44Z",
      "side": 1,
      "message": "This import seems no longer used. You can remove it manually or do Ctrl-Shift-o for automated import management to do it for you.",
      "revId": "e14cc2d3206a75b45b26d2b6a46c60248950f8fd",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_1918b934",
        "filename": "cross/org.eclipse.cdt.launch.remote/src/org/eclipse/cdt/launch/remote/RemoteHelper.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 938
      },
      "writtenOn": "2017-02-15T15:45:59Z",
      "side": 1,
      "message": "\"Since Eclipse 3.6, implementations shall also make a best effort to consult UNIX umask in order to set the same attributes for other access groups. This setting of attributes for others may change the file system state even if an attribute appears to be set for the current user already.\"\n\nIt seems that the order we set the flags for owner/group/other might change the end result, depending on umask. If I interpret the documentation correctly, I think you did it in the correct order to ensure to end-up with all-open execute perms. But I am curious if you have experimented with this?",
      "revId": "e14cc2d3206a75b45b26d2b6a46c60248950f8fd",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_a358615e",
        "filename": "cross/org.eclipse.cdt.launch.remote/src/org/eclipse/cdt/launch/remote/RemoteHelper.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 1069
      },
      "writtenOn": "2017-02-21T16:14:58Z",
      "side": 1,
      "message": "Another question, should I pass \"monitor\" as the last argument to putInfo?",
      "range": {
        "startLine": 127,
        "startChar": 58,
        "endLine": 127,
        "endChar": 62
      },
      "revId": "e14cc2d3206a75b45b26d2b6a46c60248950f8fd",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_031e7597",
        "filename": "cross/org.eclipse.cdt.launch.remote/src/org/eclipse/cdt/launch/remote/RemoteHelper.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 1069
      },
      "writtenOn": "2017-02-21T16:14:58Z",
      "side": 1,
      "message": "The order of the three setAttribute calls definitely doesn\u0027t matter, since all they do is set a bit in a bit field [1], which is commutative.\n\nI have read the bug that lead to the introduction of this comment [1], and here\u0027s the important bit:\n\n\u003cquote\u003e\nThis is needed in an SCM system for example if a file is marked as executable, then it should be brought over and the execute bit set not just for owner, but according to the umask. It is exactly the role of per-process umask to determine who gets permission when it is only known generically (i.e. this file is executable).\n\u003c/quote\u003e\n\nIn other works, some implementations could decide that when you set a file owner-executable, they\u0027ll consult the umask to maybe set the file group-executable and other-executable as well.  So when you set some bits, you might end up with more bits set than expected, but never less.  I couldn\u0027t find an implementation that does this however.\n\nIn our case it doesn\u0027t really matter because we force all three executable bits to 1, so they will always end up all set.  In reality, we only care that the user/owner has the permission to execute the file, so we could also skip setting it for group/others...\n\n[1] https://bugs.eclipse.org/bugs/show_bug.cgi?id\u003d259643",
      "parentUuid": "a7c23755_1918b934",
      "revId": "e14cc2d3206a75b45b26d2b6a46c60248950f8fd",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_a33dc17b",
        "filename": "cross/org.eclipse.cdt.launch.remote/src/org/eclipse/cdt/launch/remote/RemoteHelper.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 938
      },
      "writtenOn": "2017-02-21T17:40:44Z",
      "side": 1,
      "message": "Good question. IIUC you should not pass monitor, since it was already used by \"localFile.copy()\". You could I think do like was done before your patch and create a new SubProgressMonitor, using \"monitor\" as parent. \n\nI am not sure this is very useful in this case, unless maybe we have a very slow target or if the call to putInfo() can block; then cancelling could be cool. But killing the session in that case could also work I guess.",
      "parentUuid": "a7c23755_a358615e",
      "range": {
        "startLine": 127,
        "startChar": 58,
        "endLine": 127,
        "endChar": 62
      },
      "revId": "e14cc2d3206a75b45b26d2b6a46c60248950f8fd",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a7c23755_c3347d96",
        "filename": "cross/org.eclipse.cdt.launch.remote/src/org/eclipse/cdt/launch/remote/RemoteHelper.java",
        "patchSetId": 3
      },
      "lineNbr": 127,
      "author": {
        "id": 938
      },
      "writtenOn": "2017-02-21T17:40:44Z",
      "side": 1,
      "message": "thanks for the details.",
      "parentUuid": "a7c23755_031e7597",
      "revId": "e14cc2d3206a75b45b26d2b6a46c60248950f8fd",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
{
  "comments": [
    {
      "key": {
        "uuid": "e7dfcf21_d792545c",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/GdbSourceLookupDirector.java",
        "patchSetId": 28
      },
      "lineNbr": 151,
      "author": {
        "id": 457
      },
      "writtenOn": "2016-03-16T03:40:09Z",
      "side": 1,
      "message": "I still don\u0027t think this is right :)  But maybe I\u0027m not understanding the big picture...\nI wrote a new test to illustrate better, and I pushed a new patchset with that test.\nHere is my thought process.\nOnce a valid substitute mapping is found above, it should be used; meaning that we should not\ngo to the next mapping.  Going to the next mapping could screw up if that mapping is wrong\n(I\u0027m not sure the user would ever create such a mapping though... but solely based on the\ncode review, it seems possible).\nHow to we know it is a *valid* substitute mapping?  We have to call getCompilcationPath()\nand make sure it does find a mapping for sourceName.  If we do, we must return right away.\t\nThe below should address the problem:\n\t\t\tif (container instanceof IMappingSourceContainer) {\n\t\t\t\tIPath mappedPath \u003d ((IMappingSourceContainer) container).getCompilationPath(sourceName);\n\n\t\t\t\tif (mappedPath !\u003d null) {\n\t\t\t\t    // The path mapping is applicable to sourceName\n\t\t\t\t    // First check if the backend is handling those mappings automatically\n\t\t\t\t    if (container instanceof MappingSourceContainer\n\t\t\t\t\t\t\u0026\u0026 ((MappingSourceContainer) container).isMappingWithBackendEnabled()) {\n    \t\t\t\t\t/*\n\t\t\t\t\t     * This mapping has been handled by GDB backend (i.e. it was\n\t\t\t\t\t     * collected by collectSubstitutionsPaths to pass to gdb\u0027s\n\t\t\t\t\t     * \"set substitute-path\").\n\t\t\t\t\t     * \n\t\t\t\t\t     * As the containers themselves do not know whether the\n\t\t\t\t\t     * director requesting the compilation path supports backend\n\t\t\t\t\t     * mapping we cannot rely on the call to getCompilationPath\n\t\t\t\t\t     * but need to force a null here.\n\t\t\t\t\t     */\n\t\t\t\t\t    return new Path(sourceName);\n\t\t\t\t\t}\n\t\t\t\t    return mappedPath;\n\t\t\t\t}\n\t\t\t} else if (container.isComposite()) {\n\t\t\t...",
      "revId": "f8aa3ca2c94634c5e017f835ab5e9d61dbe3a047",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e7dfcf21_3d7439f1",
        "filename": "dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/gdb/launching/GdbSourceLookupDirector.java",
        "patchSetId": 28
      },
      "lineNbr": 151,
      "author": {
        "id": 27769
      },
      "writtenOn": "2016-03-16T19:45:57Z",
      "side": 1,
      "message": "OK, there are two things going on in this piece of code. There was a clear bug that has now been fixed.\n\nNow what is left is much more woolly. \n\nI don\u0027t think there should be such an early exit from the loop. This is because if the user really wants to have two apparently conflicting mappings we should let them. \n\nThis case is slightly contrived, but derived on some real world issue we have with a customer. In the customers case the install has two sets of pre-built source code, most of the code is built continuously, but some of the big libraries  are built less often. In the install directory you have something like this:\n\n    /user/install/location/main.c\n    /user/install/location/lib/lib.c\n\nAt build time the files were here:\n\n    /build/continuous/main.c\n    /build/nightly/lib/lib.c\n\nThis leads to a case of mappings like this:\n\n    /build/continuous -\u003e /user/install/location\n    /build/nightly/lib -\u003e /user/install/location/lib\n\nIn this case it is obvious that CDT cannot know which one of the mappings is the correct one to resolve (unless we do like GDB and start reading debug info). \n\nNow extend the case to one where the user has set the first to be substitute-path and the second to be mapping (for unknown/contrived reason*). Pass in /user/install/location/lib/lib.c and the loop will exit early, meaning that /user/install/location/lib/lib.c is passed to GDB and the breakpoint fails to insert correctly.\n\nWithout the early exit you can also create a case that fails. However I would argue we should not be doing the check at all since it can be wrong.\n\nBTW fortunately the above case does work with this patch. The more complicated case that is impossible without subsitute-path (and more closely matches the real case we have with one of our customers is):\n\nSupplied in the installation:\n\n    /user/install/location/main.c\n    /user/install/location/lib.c\n\nAt build time the files were:\n\n    /build/continuous/main.c\n    /build/nightly/lib/lib.c\n\nIn addition, the user edits/adds file like this:\n\n    /user/install/location/user.c\n\nSo you need a path mapping like this:\n\n    /build/continuous -\u003e /user/install/location\n    /build/nightly -\u003e /user/install/location\n\nKeeping in mind that one of the cases (user.c) no mapping should apply at all!\n\nIf you want, this script simulates that in your /tmp directory\n\n\tmkdir -p /tmp/build/continuous\n\tmkdir -p /tmp/build/nightly\n\tmkdir -p /tmp/user/install/location\n\n\t# this part is the build machine, in reality the o files end up in libraries\n\techo \"int main() {extern int lib(); lib();extern int user(); user();}\" \u003e /tmp/build/continuous/main.c\n\techo \"int lib() {}\" \u003e /tmp/build/nightly/lib.c\n\tgcc -g -c /tmp/build/continuous/main.c -o /tmp/build/continuous/main.o\n\tgcc -g -c /tmp/build/nightly/lib.c -o /tmp/build/nightly/lib.o\n\n\t# simulate the install (we do it with a mv because the original is on the build machine)\n\tmv -fv /tmp/build/continuous/main.* /tmp/user/install/location\n\tmv -fv /tmp/build/nightly/lib.* /tmp/user/install/location\n\n\t# this is the user adding in there own bit and linking it together\n\techo \"int user() {}\" \u003e /tmp/user/install/location/user.c\n\tgcc -g -c /tmp/user/install/location/user.c -o /tmp/user/install/location/user.o\n\tgcc -g /tmp/user/install/location/user.o \\\n               /tmp/user/install/location/lib.o \\\n               /tmp/user/install/location/main.o \\\n            -o /tmp/user/install/location/example.elf\n\n\tgdb --interpreter\u003dmi2 /tmp/user/install/location/example.elf \\\n          -ex \"set substitute-path /tmp/build/nightly /tmp/user/install/location\" \\\n          -ex \"set substitute-path /tmp/build/continuous /tmp/user/install/location\" \\\n          -ex \"b /tmp/user/install/location/main.c:1\" \\\n          -ex \"b /tmp/user/install/location/lib.c:1\" \\\n          -ex \"b /tmp/user/install/location/user.c:1\"\n\n\nObserve how GDB has correctly resolved the three breakpoints to the correct build location (file field) and current location (fullname field)\n\n\t\u003dbreakpoint-created,bkpt\u003d{number\u003d\"1\",type\u003d\"breakpoint\",disp\u003d\"keep\",enabled\u003d\"y\",addr\u003d\"0x0000000000400508\",func\u003d\"main\",file\u003d\"/tmp/build/continuous/main.c\",fullname\u003d\"/tmp/user/install/location/main.c\",line\u003d\"1\",thread-groups\u003d[\"i1\"],times\u003d\"0\",original-location\u003d\"/tmp/user/install/location/main.c:1\"}\n\t\u003dbreakpoint-created,bkpt\u003d{number\u003d\"2\",type\u003d\"breakpoint\",disp\u003d\"keep\",enabled\u003d\"y\",addr\u003d\"0x0000000000400501\",func\u003d\"lib\",file\u003d\"/tmp/build/nightly/lib.c\",fullname\u003d\"/tmp/user/install/location/lib.c\",line\u003d\"1\",thread-groups\u003d[\"i1\"],times\u003d\"0\",original-location\u003d\"/tmp/user/install/location/lib.c:1\"}\n\t\u003dbreakpoint-created,bkpt\u003d{number\u003d\"3\",type\u003d\"breakpoint\",disp\u003d\"keep\",enabled\u003d\"y\",addr\u003d\"0x00000000004004fa\",func\u003d\"user\",file\u003d\"/tmp/user/install/location/user.c\",fullname\u003d\"/tmp/user/install/location/user.c\",line\u003d\"1\",thread-groups\u003d[\"i1\"],times\u003d\"0\",original-location\u003d\"/tmp/user/install/location/user.c:1\"}",
      "parentUuid": "e7dfcf21_d792545c",
      "revId": "f8aa3ca2c94634c5e017f835ab5e9d61dbe3a047",
      "serverId": "97ee7c02-f12f-4043-b43e-dea463d88b31",
      "unresolved": false
    }
  ]
}
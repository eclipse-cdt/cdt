/*
 * generated by Xtext 2.10.0
 */
package org.eclipse.cdt.linkerscript.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.cdt.linkerscript.linkerScript.AlignCall;
import org.eclipse.cdt.linkerscript.linkerScript.Assignment;
import org.eclipse.cdt.linkerscript.linkerScript.AssignmentHidden;
import org.eclipse.cdt.linkerscript.linkerScript.AssignmentProvide;
import org.eclipse.cdt.linkerscript.linkerScript.AssignmentProvideHidden;
import org.eclipse.cdt.linkerscript.linkerScript.InputSectionFile;
import org.eclipse.cdt.linkerscript.linkerScript.InputSectionFlags;
import org.eclipse.cdt.linkerscript.linkerScript.InputSectionWild;
import org.eclipse.cdt.linkerscript.linkerScript.LBinaryOperation;
import org.eclipse.cdt.linkerscript.linkerScript.LFeatureCall;
import org.eclipse.cdt.linkerscript.linkerScript.LNumberLiteral;
import org.eclipse.cdt.linkerscript.linkerScript.LPostfixOperation;
import org.eclipse.cdt.linkerscript.linkerScript.LUnaryOperation;
import org.eclipse.cdt.linkerscript.linkerScript.LVariable;
import org.eclipse.cdt.linkerscript.linkerScript.LengthCall;
import org.eclipse.cdt.linkerscript.linkerScript.LinkerScript;
import org.eclipse.cdt.linkerscript.linkerScript.LinkerScriptPackage;
import org.eclipse.cdt.linkerscript.linkerScript.Memory;
import org.eclipse.cdt.linkerscript.linkerScript.MemoryCommand;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSection;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionAlignExpression;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionAlignWithInput;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionConstraintOnlyIfRO;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionConstraintOnlyIfRW;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionConstraintSpecial;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionTypeCopy;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionTypeDSect;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionTypeInfo;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionTypeNoLoad;
import org.eclipse.cdt.linkerscript.linkerScript.OutputSectionTypeOverlay;
import org.eclipse.cdt.linkerscript.linkerScript.SectionsCommand;
import org.eclipse.cdt.linkerscript.linkerScript.StatementAssert;
import org.eclipse.cdt.linkerscript.linkerScript.StatementAssignment;
import org.eclipse.cdt.linkerscript.linkerScript.StatementConstructors;
import org.eclipse.cdt.linkerscript.linkerScript.StatementConstructorsSorted;
import org.eclipse.cdt.linkerscript.linkerScript.StatementCreateObjectSymbols;
import org.eclipse.cdt.linkerscript.linkerScript.StatementData;
import org.eclipse.cdt.linkerscript.linkerScript.StatementFill;
import org.eclipse.cdt.linkerscript.linkerScript.StatementInclude;
import org.eclipse.cdt.linkerscript.linkerScript.StatementInputSection;
import org.eclipse.cdt.linkerscript.linkerScript.StatementNop;
import org.eclipse.cdt.linkerscript.linkerScript.Wildcard;
import org.eclipse.cdt.linkerscript.linkerScript.WildcardSortAlign;
import org.eclipse.cdt.linkerscript.linkerScript.WildcardSortAlignName;
import org.eclipse.cdt.linkerscript.linkerScript.WildcardSortInitPriority;
import org.eclipse.cdt.linkerscript.linkerScript.WildcardSortName;
import org.eclipse.cdt.linkerscript.linkerScript.WildcardSortNameAlign;
import org.eclipse.cdt.linkerscript.linkerScript.WildcardSortNone;
import org.eclipse.cdt.linkerscript.services.LinkerScriptGrammarAccess;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LinkerScriptSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private LinkerScriptGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == LinkerScriptPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LinkerScriptPackage.ALIGN_CALL:
				sequence_AlignCall(context, (AlignCall) semanticObject); 
				return; 
			case LinkerScriptPackage.ASSIGNMENT:
				if (rule == grammarAccess.getAssignmentRuleRule()) {
					sequence_AssignmentRule(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case LinkerScriptPackage.ASSIGNMENT_HIDDEN:
				sequence_AssignmentRule(context, (AssignmentHidden) semanticObject); 
				return; 
			case LinkerScriptPackage.ASSIGNMENT_PROVIDE:
				sequence_AssignmentRule(context, (AssignmentProvide) semanticObject); 
				return; 
			case LinkerScriptPackage.ASSIGNMENT_PROVIDE_HIDDEN:
				sequence_AssignmentRule(context, (AssignmentProvideHidden) semanticObject); 
				return; 
			case LinkerScriptPackage.INPUT_SECTION_FILE:
				sequence_InputSection(context, (InputSectionFile) semanticObject); 
				return; 
			case LinkerScriptPackage.INPUT_SECTION_FLAGS:
				sequence_InputSectionFlags(context, (InputSectionFlags) semanticObject); 
				return; 
			case LinkerScriptPackage.INPUT_SECTION_WILD:
				sequence_InputSection(context, (InputSectionWild) semanticObject); 
				return; 
			case LinkerScriptPackage.LBINARY_OPERATION:
				sequence_LAdditiveExpression_LAndExpression_LAssignment_LBitwiseAndExpression_LBitwiseOrExpression_LEqualityExpression_LMultiplicativeExpression_LOrExpression_LOtherOperatorExpression_LRelationalExpression(context, (LBinaryOperation) semanticObject); 
				return; 
			case LinkerScriptPackage.LFEATURE_CALL:
				sequence_LFeatureCall(context, (LFeatureCall) semanticObject); 
				return; 
			case LinkerScriptPackage.LNUMBER_LITERAL:
				sequence_LNumberLiteral(context, (LNumberLiteral) semanticObject); 
				return; 
			case LinkerScriptPackage.LPOSTFIX_OPERATION:
				sequence_LPostfixOperation(context, (LPostfixOperation) semanticObject); 
				return; 
			case LinkerScriptPackage.LUNARY_OPERATION:
				sequence_LUnaryOperation(context, (LUnaryOperation) semanticObject); 
				return; 
			case LinkerScriptPackage.LVARIABLE:
				sequence_LVariable(context, (LVariable) semanticObject); 
				return; 
			case LinkerScriptPackage.LENGTH_CALL:
				sequence_LengthCall(context, (LengthCall) semanticObject); 
				return; 
			case LinkerScriptPackage.LINKER_SCRIPT:
				sequence_LinkerScript(context, (LinkerScript) semanticObject); 
				return; 
			case LinkerScriptPackage.MEMORY:
				sequence_Memory(context, (Memory) semanticObject); 
				return; 
			case LinkerScriptPackage.MEMORY_COMMAND:
				sequence_MemoryCommand(context, (MemoryCommand) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION:
				sequence_OutputSection(context, (OutputSection) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_ALIGN_EXPRESSION:
				sequence_OutputSectionAlign(context, (OutputSectionAlignExpression) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_ALIGN_WITH_INPUT:
				sequence_OutputSectionAlign(context, (OutputSectionAlignWithInput) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_CONSTRAINT_ONLY_IF_RO:
				sequence_OutputSectionConstraint(context, (OutputSectionConstraintOnlyIfRO) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_CONSTRAINT_ONLY_IF_RW:
				sequence_OutputSectionConstraint(context, (OutputSectionConstraintOnlyIfRW) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_CONSTRAINT_SPECIAL:
				sequence_OutputSectionConstraint(context, (OutputSectionConstraintSpecial) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_TYPE_COPY:
				sequence_OutputSectionType(context, (OutputSectionTypeCopy) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_TYPE_DSECT:
				sequence_OutputSectionType(context, (OutputSectionTypeDSect) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_TYPE_INFO:
				sequence_OutputSectionType(context, (OutputSectionTypeInfo) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_TYPE_NO_LOAD:
				sequence_OutputSectionType(context, (OutputSectionTypeNoLoad) semanticObject); 
				return; 
			case LinkerScriptPackage.OUTPUT_SECTION_TYPE_OVERLAY:
				sequence_OutputSectionType(context, (OutputSectionTypeOverlay) semanticObject); 
				return; 
			case LinkerScriptPackage.SECTIONS_COMMAND:
				sequence_SectionsCommand(context, (SectionsCommand) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_ASSERT:
				sequence_Statement(context, (StatementAssert) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_ASSIGNMENT:
				sequence_Statement(context, (StatementAssignment) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_CONSTRUCTORS:
				sequence_Statement(context, (StatementConstructors) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_CONSTRUCTORS_SORTED:
				sequence_Statement(context, (StatementConstructorsSorted) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_CREATE_OBJECT_SYMBOLS:
				sequence_Statement(context, (StatementCreateObjectSymbols) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_DATA:
				sequence_Statement(context, (StatementData) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_FILL:
				sequence_Statement(context, (StatementFill) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_INCLUDE:
				sequence_Statement(context, (StatementInclude) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_INPUT_SECTION:
				sequence_Statement(context, (StatementInputSection) semanticObject); 
				return; 
			case LinkerScriptPackage.STATEMENT_NOP:
				sequence_Statement(context, (StatementNop) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD:
				sequence_Wildcard(context, (Wildcard) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD_SORT_ALIGN:
				sequence_WildcardRule(context, (WildcardSortAlign) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD_SORT_ALIGN_NAME:
				sequence_WildcardRule(context, (WildcardSortAlignName) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD_SORT_INIT_PRIORITY:
				sequence_WildcardRule(context, (WildcardSortInitPriority) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD_SORT_NAME:
				sequence_WildcardRule(context, (WildcardSortName) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD_SORT_NAME_ALIGN:
				sequence_WildcardRule(context, (WildcardSortNameAlign) semanticObject); 
				return; 
			case LinkerScriptPackage.WILDCARD_SORT_NONE:
				sequence_WildcardRule(context, (WildcardSortNone) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     LExpression returns AlignCall
	 *     LAssignment returns AlignCall
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LOrExpression returns AlignCall
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LAndExpression returns AlignCall
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LBitwiseOrExpression returns AlignCall
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LBitwiseAndExpression returns AlignCall
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LEqualityExpression returns AlignCall
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LRelationalExpression returns AlignCall
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LOtherOperatorExpression returns AlignCall
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LAdditiveExpression returns AlignCall
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LMultiplicativeExpression returns AlignCall
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns AlignCall
	 *     LUnaryOperation returns AlignCall
	 *     LPostfixOperation returns AlignCall
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns AlignCall
	 *     LPrimaryExpression returns AlignCall
	 *     LParenthesizedExpression returns AlignCall
	 *     AlignCall returns AlignCall
	 *
	 * Constraint:
	 *     (expOrAlign=LExpression align=LExpression?)
	 */
	protected void sequence_AlignCall(ISerializationContext context, AlignCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentRule returns Assignment
	 *
	 * Constraint:
	 *     (name=WildID feature=OpAssign exp=LExpression)
	 */
	protected void sequence_AssignmentRule(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getNameWildIDParserRuleCall_0_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getFeatureOpAssignParserRuleCall_0_2_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getExpLExpressionParserRuleCall_0_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentRule returns AssignmentHidden
	 *
	 * Constraint:
	 *     (name=WildID feature='=' exp=LExpression)
	 */
	protected void sequence_AssignmentRule(ISerializationContext context, AssignmentHidden semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getNameWildIDParserRuleCall_1_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getFeatureEqualsSignKeyword_1_4_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getExpLExpressionParserRuleCall_1_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentRule returns AssignmentProvide
	 *
	 * Constraint:
	 *     (name=WildID feature='=' exp=LExpression)
	 */
	protected void sequence_AssignmentRule(ISerializationContext context, AssignmentProvide semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getNameWildIDParserRuleCall_2_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getFeatureEqualsSignKeyword_2_4_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getExpLExpressionParserRuleCall_2_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     AssignmentRule returns AssignmentProvideHidden
	 *
	 * Constraint:
	 *     (name=WildID feature='=' exp=LExpression)
	 */
	protected void sequence_AssignmentRule(ISerializationContext context, AssignmentProvideHidden semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getNameWildIDParserRuleCall_3_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getFeatureEqualsSignKeyword_3_4_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getAssignmentRuleAccess().getExpLExpressionParserRuleCall_3_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Assignment returns Assignment
	 *
	 * Constraint:
	 *     (name=WildID feature=OpAssign exp=LExpression)
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__NAME));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__FEATURE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.ASSIGNMENT__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignmentAccess().getNameWildIDParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getAssignmentAccess().getFeatureOpAssignParserRuleCall_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getAssignmentAccess().getExpLExpressionParserRuleCall_2_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     InputSectionFlags returns InputSectionFlags
	 *
	 * Constraint:
	 *     (flags+=WildID flags+=WildID*)
	 */
	protected void sequence_InputSectionFlags(ISerializationContext context, InputSectionFlags semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputSection returns InputSectionFile
	 *
	 * Constraint:
	 *     (((flags+=WildID flags+=WildID*)? file=WildID) | (keep?='KEEP' (flags+=WildID flags+=WildID*)? file=WildID))
	 */
	protected void sequence_InputSection(ISerializationContext context, InputSectionFile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     InputSection returns InputSectionWild
	 *
	 * Constraint:
	 *     (
	 *         ((flags+=WildID flags+=WildID*)? wildFile=WildcardRule sections+=WildcardRule sections+=WildcardRule*) | 
	 *         (keep?='KEEP' (flags+=WildID flags+=WildID*)? wildFile=WildcardRule sections+=WildcardRule sections+=WildcardRule*)
	 *     )
	 */
	protected void sequence_InputSection(ISerializationContext context, InputSectionWild semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LExpression returns LBinaryOperation
	 *     LAssignment returns LBinaryOperation
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LOrExpression returns LBinaryOperation
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LAndExpression returns LBinaryOperation
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LBitwiseOrExpression returns LBinaryOperation
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LBitwiseAndExpression returns LBinaryOperation
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LEqualityExpression returns LBinaryOperation
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LRelationalExpression returns LBinaryOperation
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LOtherOperatorExpression returns LBinaryOperation
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LAdditiveExpression returns LBinaryOperation
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LMultiplicativeExpression returns LBinaryOperation
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns LBinaryOperation
	 *     LUnaryOperation returns LBinaryOperation
	 *     LPostfixOperation returns LBinaryOperation
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns LBinaryOperation
	 *     LPrimaryExpression returns LBinaryOperation
	 *     LParenthesizedExpression returns LBinaryOperation
	 *
	 * Constraint:
	 *     (
	 *         (leftOperand=LAssignment_LBinaryOperation_1_0_0_0 feature=OpMultiAssign rightOperand=LAssignment) | 
	 *         (leftOperand=LOrExpression_LBinaryOperation_1_0_0_0 feature=OpOr rightOperand=LAndExpression) | 
	 *         (leftOperand=LAndExpression_LBinaryOperation_1_0_0_0 feature=OpAnd rightOperand=LBitwiseOrExpression) | 
	 *         (leftOperand=LBitwiseOrExpression_LBinaryOperation_1_0_0_0 feature=OpBitwiseOr rightOperand=LBitwiseAndExpression) | 
	 *         (leftOperand=LBitwiseAndExpression_LBinaryOperation_1_0_0_0 feature=OpBitwiseAnd rightOperand=LEqualityExpression) | 
	 *         (leftOperand=LEqualityExpression_LBinaryOperation_1_0_0_0 feature=OpEquality rightOperand=LRelationalExpression) | 
	 *         (leftOperand=LRelationalExpression_LBinaryOperation_1_0_0_0 feature=OpCompare rightOperand=LOtherOperatorExpression) | 
	 *         (leftOperand=LOtherOperatorExpression_LBinaryOperation_1_0_0_0 feature=OpOther rightOperand=LAdditiveExpression) | 
	 *         (leftOperand=LAdditiveExpression_LBinaryOperation_1_0_0_0 feature=OpAdd rightOperand=LMultiplicativeExpression) | 
	 *         (leftOperand=LMultiplicativeExpression_LBinaryOperation_1_0_0_0 feature=OpMulti rightOperand=LUnaryOperation)
	 *     )
	 */
	protected void sequence_LAdditiveExpression_LAndExpression_LAssignment_LBitwiseAndExpression_LBitwiseOrExpression_LEqualityExpression_LMultiplicativeExpression_LOrExpression_LOtherOperatorExpression_LRelationalExpression(ISerializationContext context, LBinaryOperation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LFeatureCall returns LFeatureCall
	 *
	 * Constraint:
	 *     (feature=ValidFunc (explicitOperationCall?='(' (featureCallArguments+=LExpression featureCallArguments+=LExpression*)?)?)
	 */
	protected void sequence_LFeatureCall(ISerializationContext context, LFeatureCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     LExpression returns LNumberLiteral
	 *     LAssignment returns LNumberLiteral
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LOrExpression returns LNumberLiteral
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LAndExpression returns LNumberLiteral
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LBitwiseOrExpression returns LNumberLiteral
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LBitwiseAndExpression returns LNumberLiteral
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LEqualityExpression returns LNumberLiteral
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LRelationalExpression returns LNumberLiteral
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LOtherOperatorExpression returns LNumberLiteral
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LAdditiveExpression returns LNumberLiteral
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LMultiplicativeExpression returns LNumberLiteral
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns LNumberLiteral
	 *     LUnaryOperation returns LNumberLiteral
	 *     LPostfixOperation returns LNumberLiteral
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns LNumberLiteral
	 *     LPrimaryExpression returns LNumberLiteral
	 *     LParenthesizedExpression returns LNumberLiteral
	 *     LNumberLiteral returns LNumberLiteral
	 *
	 * Constraint:
	 *     value=Number
	 */
	protected void sequence_LNumberLiteral(ISerializationContext context, LNumberLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LNUMBER_LITERAL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LNUMBER_LITERAL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLNumberLiteralAccess().getValueNumberParserRuleCall_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LExpression returns LPostfixOperation
	 *     LAssignment returns LPostfixOperation
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LOrExpression returns LPostfixOperation
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LAndExpression returns LPostfixOperation
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LBitwiseOrExpression returns LPostfixOperation
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LBitwiseAndExpression returns LPostfixOperation
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LEqualityExpression returns LPostfixOperation
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LRelationalExpression returns LPostfixOperation
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LOtherOperatorExpression returns LPostfixOperation
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LAdditiveExpression returns LPostfixOperation
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LMultiplicativeExpression returns LPostfixOperation
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns LPostfixOperation
	 *     LUnaryOperation returns LPostfixOperation
	 *     LPostfixOperation returns LPostfixOperation
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns LPostfixOperation
	 *     LPrimaryExpression returns LPostfixOperation
	 *     LParenthesizedExpression returns LPostfixOperation
	 *
	 * Constraint:
	 *     (operand=LPostfixOperation_LPostfixOperation_1_0_0 feature=OpPostfix)
	 */
	protected void sequence_LPostfixOperation(ISerializationContext context, LPostfixOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LPOSTFIX_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LPOSTFIX_OPERATION__OPERAND));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LPOSTFIX_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LPOSTFIX_OPERATION__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLPostfixOperationAccess().getLPostfixOperationOperandAction_1_0_0(), semanticObject.getOperand());
		feeder.accept(grammarAccess.getLPostfixOperationAccess().getFeatureOpPostfixParserRuleCall_1_0_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LExpression returns LUnaryOperation
	 *     LAssignment returns LUnaryOperation
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LOrExpression returns LUnaryOperation
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LAndExpression returns LUnaryOperation
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LBitwiseOrExpression returns LUnaryOperation
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LBitwiseAndExpression returns LUnaryOperation
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LEqualityExpression returns LUnaryOperation
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LRelationalExpression returns LUnaryOperation
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LOtherOperatorExpression returns LUnaryOperation
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LAdditiveExpression returns LUnaryOperation
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LMultiplicativeExpression returns LUnaryOperation
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns LUnaryOperation
	 *     LUnaryOperation returns LUnaryOperation
	 *     LPostfixOperation returns LUnaryOperation
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns LUnaryOperation
	 *     LPrimaryExpression returns LUnaryOperation
	 *     LParenthesizedExpression returns LUnaryOperation
	 *
	 * Constraint:
	 *     (feature=OpUnary operand=LUnaryOperation)
	 */
	protected void sequence_LUnaryOperation(ISerializationContext context, LUnaryOperation semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LUNARY_OPERATION__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LUNARY_OPERATION__FEATURE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LUNARY_OPERATION__OPERAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LUNARY_OPERATION__OPERAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLUnaryOperationAccess().getFeatureOpUnaryParserRuleCall_0_1_0(), semanticObject.getFeature());
		feeder.accept(grammarAccess.getLUnaryOperationAccess().getOperandLUnaryOperationParserRuleCall_0_2_0(), semanticObject.getOperand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LExpression returns LVariable
	 *     LAssignment returns LVariable
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LOrExpression returns LVariable
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LAndExpression returns LVariable
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LBitwiseOrExpression returns LVariable
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LBitwiseAndExpression returns LVariable
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LEqualityExpression returns LVariable
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LRelationalExpression returns LVariable
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LOtherOperatorExpression returns LVariable
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LAdditiveExpression returns LVariable
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LMultiplicativeExpression returns LVariable
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns LVariable
	 *     LUnaryOperation returns LVariable
	 *     LPostfixOperation returns LVariable
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns LVariable
	 *     LPrimaryExpression returns LVariable
	 *     LVariable returns LVariable
	 *     LParenthesizedExpression returns LVariable
	 *
	 * Constraint:
	 *     feature=ValidID
	 */
	protected void sequence_LVariable(ISerializationContext context, LVariable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LVARIABLE__FEATURE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LVARIABLE__FEATURE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLVariableAccess().getFeatureValidIDParserRuleCall_1_0(), semanticObject.getFeature());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LExpression returns LengthCall
	 *     LAssignment returns LengthCall
	 *     LAssignment.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LOrExpression returns LengthCall
	 *     LOrExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LAndExpression returns LengthCall
	 *     LAndExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LBitwiseOrExpression returns LengthCall
	 *     LBitwiseOrExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LBitwiseAndExpression returns LengthCall
	 *     LBitwiseAndExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LEqualityExpression returns LengthCall
	 *     LEqualityExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LRelationalExpression returns LengthCall
	 *     LRelationalExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LOtherOperatorExpression returns LengthCall
	 *     LOtherOperatorExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LAdditiveExpression returns LengthCall
	 *     LAdditiveExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LMultiplicativeExpression returns LengthCall
	 *     LMultiplicativeExpression.LBinaryOperation_1_0_0_0 returns LengthCall
	 *     LUnaryOperation returns LengthCall
	 *     LPostfixOperation returns LengthCall
	 *     LPostfixOperation.LPostfixOperation_1_0_0 returns LengthCall
	 *     LPrimaryExpression returns LengthCall
	 *     LParenthesizedExpression returns LengthCall
	 *     LengthCall returns LengthCall
	 *
	 * Constraint:
	 *     memory=ValidID
	 */
	protected void sequence_LengthCall(ISerializationContext context, LengthCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.LENGTH_CALL__MEMORY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.LENGTH_CALL__MEMORY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLengthCallAccess().getMemoryValidIDParserRuleCall_3_0(), semanticObject.getMemory());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     LinkerScript returns LinkerScript
	 *
	 * Constraint:
	 *     (memories=MemoryCommand? sections=SectionsCommand?)
	 */
	protected void sequence_LinkerScript(ISerializationContext context, LinkerScript semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MemoryCommand returns MemoryCommand
	 *
	 * Constraint:
	 *     memories+=Memory*
	 */
	protected void sequence_MemoryCommand(ISerializationContext context, MemoryCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Memory returns Memory
	 *
	 * Constraint:
	 *     (name=MemoryName attr=MemoryAttribute? origin=LExpression length=LExpression)
	 */
	protected void sequence_Memory(ISerializationContext context, Memory semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionAlign returns OutputSectionAlignExpression
	 *
	 * Constraint:
	 *     exp=LExpression
	 */
	protected void sequence_OutputSectionAlign(ISerializationContext context, OutputSectionAlignExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.OUTPUT_SECTION_ALIGN_EXPRESSION__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.OUTPUT_SECTION_ALIGN_EXPRESSION__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOutputSectionAlignAccess().getExpLExpressionParserRuleCall_0_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionAlign returns OutputSectionAlignWithInput
	 *
	 * Constraint:
	 *     {OutputSectionAlignWithInput}
	 */
	protected void sequence_OutputSectionAlign(ISerializationContext context, OutputSectionAlignWithInput semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionConstraint returns OutputSectionConstraintOnlyIfRO
	 *
	 * Constraint:
	 *     {OutputSectionConstraintOnlyIfRO}
	 */
	protected void sequence_OutputSectionConstraint(ISerializationContext context, OutputSectionConstraintOnlyIfRO semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionConstraint returns OutputSectionConstraintOnlyIfRW
	 *
	 * Constraint:
	 *     {OutputSectionConstraintOnlyIfRW}
	 */
	protected void sequence_OutputSectionConstraint(ISerializationContext context, OutputSectionConstraintOnlyIfRW semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionConstraint returns OutputSectionConstraintSpecial
	 *
	 * Constraint:
	 *     {OutputSectionConstraintSpecial}
	 */
	protected void sequence_OutputSectionConstraint(ISerializationContext context, OutputSectionConstraintSpecial semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionType returns OutputSectionTypeCopy
	 *
	 * Constraint:
	 *     {OutputSectionTypeCopy}
	 */
	protected void sequence_OutputSectionType(ISerializationContext context, OutputSectionTypeCopy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionType returns OutputSectionTypeDSect
	 *
	 * Constraint:
	 *     {OutputSectionTypeDSect}
	 */
	protected void sequence_OutputSectionType(ISerializationContext context, OutputSectionTypeDSect semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionType returns OutputSectionTypeInfo
	 *
	 * Constraint:
	 *     {OutputSectionTypeInfo}
	 */
	protected void sequence_OutputSectionType(ISerializationContext context, OutputSectionTypeInfo semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionType returns OutputSectionTypeNoLoad
	 *
	 * Constraint:
	 *     {OutputSectionTypeNoLoad}
	 */
	protected void sequence_OutputSectionType(ISerializationContext context, OutputSectionTypeNoLoad semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSectionType returns OutputSectionTypeOverlay
	 *
	 * Constraint:
	 *     {OutputSectionTypeOverlay}
	 */
	protected void sequence_OutputSectionType(ISerializationContext context, OutputSectionTypeOverlay semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     OutputSection returns OutputSection
	 *
	 * Constraint:
	 *     (
	 *         name=ValidID 
	 *         address=LExpression? 
	 *         type=OutputSectionType? 
	 *         at=LExpression? 
	 *         align=OutputSectionAlign? 
	 *         subAlign=LExpression? 
	 *         constraint=OutputSectionConstraint? 
	 *         statements+=Statement* 
	 *         memory=ValidID? 
	 *         atMemory=ValidID? 
	 *         phdrs+=ValidID* 
	 *         fill=LExpression?
	 *     )
	 */
	protected void sequence_OutputSection(ISerializationContext context, OutputSection semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SectionsCommand returns SectionsCommand
	 *
	 * Constraint:
	 *     sections+=OutputSection*
	 */
	protected void sequence_SectionsCommand(ISerializationContext context, SectionsCommand semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementAssert
	 *
	 * Constraint:
	 *     (exp=LExpression message=ValidID)
	 */
	protected void sequence_Statement(ISerializationContext context, StatementAssert semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_ASSERT__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_ASSERT__EXP));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_ASSERT__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_ASSERT__MESSAGE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getExpLExpressionParserRuleCall_6_3_0(), semanticObject.getExp());
		feeder.accept(grammarAccess.getStatementAccess().getMessageValidIDParserRuleCall_6_5_0(), semanticObject.getMessage());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementAssignment
	 *
	 * Constraint:
	 *     assignment=AssignmentRule
	 */
	protected void sequence_Statement(ISerializationContext context, StatementAssignment semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_ASSIGNMENT__ASSIGNMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_ASSIGNMENT__ASSIGNMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getAssignmentAssignmentRuleParserRuleCall_0_1_0(), semanticObject.getAssignment());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementConstructors
	 *
	 * Constraint:
	 *     {StatementConstructors}
	 */
	protected void sequence_Statement(ISerializationContext context, StatementConstructors semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementConstructorsSorted
	 *
	 * Constraint:
	 *     {StatementConstructorsSorted}
	 */
	protected void sequence_Statement(ISerializationContext context, StatementConstructorsSorted semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementCreateObjectSymbols
	 *
	 * Constraint:
	 *     {StatementCreateObjectSymbols}
	 */
	protected void sequence_Statement(ISerializationContext context, StatementCreateObjectSymbols semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementData
	 *
	 * Constraint:
	 *     (size=StatementDataSize data=LExpression)
	 */
	protected void sequence_Statement(ISerializationContext context, StatementData semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_DATA__SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_DATA__SIZE));
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_DATA__DATA) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_DATA__DATA));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getSizeStatementDataSizeParserRuleCall_4_1_0(), semanticObject.getSize());
		feeder.accept(grammarAccess.getStatementAccess().getDataLExpressionParserRuleCall_4_3_0(), semanticObject.getData());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementFill
	 *
	 * Constraint:
	 *     fill=LExpression
	 */
	protected void sequence_Statement(ISerializationContext context, StatementFill semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_FILL__FILL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_FILL__FILL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getFillLExpressionParserRuleCall_5_3_0(), semanticObject.getFill());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementInclude
	 *
	 * Constraint:
	 *     filename=WildID
	 */
	protected void sequence_Statement(ISerializationContext context, StatementInclude semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_INCLUDE__FILENAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_INCLUDE__FILENAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getFilenameWildIDParserRuleCall_7_2_0(), semanticObject.getFilename());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementInputSection
	 *
	 * Constraint:
	 *     spec=InputSection
	 */
	protected void sequence_Statement(ISerializationContext context, StatementInputSection semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.STATEMENT_INPUT_SECTION__SPEC) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.STATEMENT_INPUT_SECTION__SPEC));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getStatementAccess().getSpecInputSectionParserRuleCall_8_1_0(), semanticObject.getSpec());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StatementNop
	 *
	 * Constraint:
	 *     {StatementNop}
	 */
	protected void sequence_Statement(ISerializationContext context, StatementNop semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WildcardRule returns WildcardSortAlign
	 *
	 * Constraint:
	 *     (name=WildID | name=WildID)
	 */
	protected void sequence_WildcardRule(ISerializationContext context, WildcardSortAlign semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WildcardRule returns WildcardSortAlignName
	 *
	 * Constraint:
	 *     name=WildID
	 */
	protected void sequence_WildcardRule(ISerializationContext context, WildcardSortAlignName semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.WILDCARD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.WILDCARD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWildcardRuleAccess().getNameWildIDParserRuleCall_7_5_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WildcardRule returns WildcardSortInitPriority
	 *
	 * Constraint:
	 *     name=WildID
	 */
	protected void sequence_WildcardRule(ISerializationContext context, WildcardSortInitPriority semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.WILDCARD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.WILDCARD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWildcardRuleAccess().getNameWildIDParserRuleCall_10_3_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WildcardRule returns WildcardSortName
	 *
	 * Constraint:
	 *     (name=WildID | name=WildID | (excludes+=WildID+ name=WildID))
	 */
	protected void sequence_WildcardRule(ISerializationContext context, WildcardSortName semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     WildcardRule returns WildcardSortNameAlign
	 *
	 * Constraint:
	 *     name=WildID
	 */
	protected void sequence_WildcardRule(ISerializationContext context, WildcardSortNameAlign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LinkerScriptPackage.Literals.WILDCARD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LinkerScriptPackage.Literals.WILDCARD__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWildcardRuleAccess().getNameWildIDParserRuleCall_5_5_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     WildcardRule returns WildcardSortNone
	 *
	 * Constraint:
	 *     (name=WildID | (excludes+=WildID+ name=WildID) | name=WildID)
	 */
	protected void sequence_WildcardRule(ISerializationContext context, WildcardSortNone semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Wildcard returns Wildcard
	 *
	 * Constraint:
	 *     (name=ValidID excludes+=ValidID)
	 */
	protected void sequence_Wildcard(ISerializationContext context, Wildcard semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}

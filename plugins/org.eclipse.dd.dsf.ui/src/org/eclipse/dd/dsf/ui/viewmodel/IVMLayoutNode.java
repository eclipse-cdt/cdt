/*******************************************************************************
 * Copyright (c) 2006 Wind River Systems and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Wind River Systems - initial API and implementation
 *******************************************************************************/
package org.eclipse.dd.dsf.ui.viewmodel;

import org.eclipse.dd.dsf.concurrent.ConfinedToDsfExecutor;
import org.eclipse.dd.dsf.concurrent.RequestMonitor;
import org.eclipse.dd.dsf.ui.viewmodel.dm.AbstractDMVMProvider;
import org.eclipse.debug.internal.ui.viewers.model.provisional.IChildrenCountUpdate;
import org.eclipse.debug.internal.ui.viewers.model.provisional.IChildrenUpdate;
import org.eclipse.debug.internal.ui.viewers.model.provisional.IHasChildrenUpdate;
import org.eclipse.debug.internal.ui.viewers.model.provisional.IModelDelta;

/**
 * View model layout nodes are combined together into a tree, to collectively 
 * define the layout of a view.  Each layout node generates elements of type 
 * IVMContext which are then stored in the viewer.
 * <p>
 * Besides the standard Data Model Context based implementation, this 
 * node could be implemented to present data from any source, not necessarily
 * DSF services.  It could also define a static node which operates on basis
 * of other data in the view tree.   
 * @see AbstractDMVMProvider
 */
@ConfinedToDsfExecutor("")
@SuppressWarnings("restriction")
public interface IVMLayoutNode 
{
    /**
     * Retrieves the associated VM Provider.
     */
    public IVMProvider getVMProvider();
    
    /**
     * Retrieves information whether for a given path in the viewer, 
     * there are any elements available in this node.
     * 
     * @param updates The update objects which need to be filled in with results 
     * calculated by this method.  
     * Even though the "children" interface is reused, the updates refer to the 
     * elements of this layout node, and not it's children.
     */
    public void updateHasElements(IHasChildrenUpdate[] updates);

    /**
     * Retrieves the number of available elements in this node for the given 
     * path in the viewer.
     * 
     * @param updates The update object which needs to be filled in with result 
     * calculated by this method.  
     * Even though the "children" interface is reused, the updates refer to the 
     * elements of this layout node, and not it's children.
     */
    public void updateElementCount(IChildrenCountUpdate update);
    
    /**
     * Retrieves the element objects of this node for the given path in the 
     * viewer, and for the given range of indexes. <br> 
     * NOTE: update.getOffset() and update.getLength() may return -1. 
     * The range of children, denoted by ILabelUpdate.getOffset() 
     * and ILabelUpdate.getLength(), may not be specified, in which case these 
     * methods may return -1. This means that all the elements should be 
     * retrieved for this node.<br>
     * 
     * @param updates The update object which needs to be filled in with result 
     * calculated by this method.  
     * Even though the "children" interface is reused, the updates refer to the 
     * elements of this layout node, and not it's children.
     */
    public void updateElements(IChildrenUpdate update);

    
    /**
     * Configures the child layout nodes for this node.
     * @param childNodes
     */
    public void setChildNodes(IVMLayoutNode[] childNodes);

    /**
     * Returns the list of child layout nodes which are configured for this node.
     */
    public IVMLayoutNode[] getChildLayoutNodes();
    
    /**
     * Returns the potential delta flags that would be generated by this node 
     * for the given event.  
     * @param event Event to process.
     * @return IModelDelta flags
     * @see #buildDelta(Object, VMDelta, int, RequestMonitor)
     * @see IModelDelta
     */
    public int getDeltaFlags(Object event);
    
    /**
     * Builds model delta information based on the given event.  
     * <p>
     * Model deltas, which are used to control the state of elements in the viewer, are 
     * generated by the layout nodes by recursively calling this method on all the nodes 
     * in the layout tree.  Each node implements two methods: {@link #getDeltaFlags(Object)}, 
     * and <code>buildDelta()</code>.  A parent node which is processing a 
     * <code>buildDelta</code> operation needs to determine which of its elements are
     * affected by a given event, set appropriate flags on these elements, and then 
     * it needs to call its child nodes with those elements to give the child nodes a 
     * chance to add onto the delta.  
     * </p>
     * <p>
     * The <code>getDeltaFlags()</code> is a synchronous
     * call which tells the parent node whether on not to call the child node's 
     * <code>buildDelta</code> with the given event.  If a child node return 
     * <code>true</code>, it only indicates that the node may add delta flags, but it
     * does not require it to do so.
     * </p>  
     * 
     * @param event Event to process.
     * @param parent Parent model delta node that this object should add delta
     * data to.
     * @param nodeOffset The offset of the first element in this node.  This offset
     * depends on the elements returned by the siblings of this layout node.
     * @param requestMonitor Return token, which notifies the caller that the calculation is
     * complete.
     */
    public void buildDelta(Object event, VMDelta parent, int nodeOffset, RequestMonitor requestMonitor);
    
    /**
     * Releases the resources held by this node.
     */
    public void dispose();
}
/*******************************************************************************
* Copyright (c) 2006, 2008 IBM Corporation and others.
* All rights reserved. This program and the accompanying materials
* are made available under the terms of the Eclipse Public License v1.0
* which accompanies this distribution, and is available at
* http://www.eclipse.org/legal/epl-v10.html
*
* Contributors:
*     IBM Corporation - initial API and implementation
*********************************************************************************/

// This file was generated by LPG

package org.eclipse.cdt.internal.core.dom.parser.upc;

import lpg.lpgjavaruntime.*;

import java.util.*;
import org.eclipse.cdt.core.dom.ast.*;
import org.eclipse.cdt.core.dom.lrparser.IParser;
import org.eclipse.cdt.core.dom.lrparser.IParserActionTokenProvider;
import org.eclipse.cdt.core.dom.lrparser.lpgextensions.FixedBacktrackingParser;
import org.eclipse.cdt.core.dom.lrparser.action.ScopedStack;

import org.eclipse.cdt.core.dom.lrparser.action.ITokenMap;
import org.eclipse.cdt.core.dom.lrparser.action.TokenMap;

import org.eclipse.cdt.internal.core.dom.parser.c.CNodeFactory;
import org.eclipse.cdt.core.dom.lrparser.action.c99.C99BuildASTParserAction;
import org.eclipse.cdt.core.dom.lrparser.action.c99.C99SecondaryParserFactory;

import org.eclipse.cdt.core.dom.parser.upc.UPCASTNodeFactory;
import org.eclipse.cdt.core.dom.parser.upc.UPCSecondaryParserFactory;
import org.eclipse.cdt.core.dom.parser.upc.UPCParserAction;
import org.eclipse.cdt.core.dom.upc.ast.IUPCASTKeywordExpression;
import org.eclipse.cdt.core.dom.upc.ast.IUPCASTSynchronizationStatement;
import org.eclipse.cdt.core.dom.upc.ast.IUPCASTUnarySizeofExpression;
import org.eclipse.cdt.core.dom.lrparser.lpgextensions.FixedBacktrackingParser;

public class UPCExpressionParser extends PrsStream implements RuleAction , IParserActionTokenProvider, IParser< IASTExpression >   
{
    private static ParseTable prs = new UPCExpressionParserprs();
    private FixedBacktrackingParser btParser;

    public FixedBacktrackingParser getParser() { return btParser; }
    private void setResult(Object object) { btParser.setSym1(object); }
    public Object getRhsSym(int i) { return btParser.getSym(i); }

    public int getRhsTokenIndex(int i) { return btParser.getToken(i); }
    public IToken getRhsIToken(int i) { return super.getIToken(getRhsTokenIndex(i)); }
    
    public int getRhsFirstTokenIndex(int i) { return btParser.getFirstToken(i); }
    public IToken getRhsFirstIToken(int i) { return super.getIToken(getRhsFirstTokenIndex(i)); }

    public int getRhsLastTokenIndex(int i) { return btParser.getLastToken(i); }
    public IToken getRhsLastIToken(int i) { return super.getIToken(getRhsLastTokenIndex(i)); }

    public int getLeftSpan() { return btParser.getFirstToken(); }
    public IToken getLeftIToken()  { return super.getIToken(getLeftSpan()); }

    public int getRightSpan() { return btParser.getLastToken(); }
    public IToken getRightIToken() { return super.getIToken(getRightSpan()); }

    public int getRhsErrorTokenIndex(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (err instanceof ErrorToken ? index : 0);
    }
    public ErrorToken getRhsErrorIToken(int i)
    {
        int index = btParser.getToken(i);
        IToken err = super.getIToken(index);
        return (ErrorToken) (err instanceof ErrorToken ? err : null);
    }

    public UPCExpressionParser(LexStream lexStream)
    {
        super(lexStream);

        try
        {
            super.remapTerminalSymbols(orderedTerminalSymbols(), UPCExpressionParserprs.EOFT_SYMBOL);
        }
        catch(NullExportedSymbolsException e) {
        }
        catch(NullTerminalSymbolsException e) {
        }
        catch(UnimplementedTerminalsException e)
        {
            java.util.ArrayList unimplemented_symbols = e.getSymbols();
            System.out.println("The Lexer will not scan the following token(s):");
            for (int i = 0; i < unimplemented_symbols.size(); i++)
            {
                Integer id = (Integer) unimplemented_symbols.get(i);
                System.out.println("    " + UPCExpressionParsersym.orderedTerminalSymbols[id.intValue()]);               
            }
            System.out.println();                        
        }
        catch(UndefinedEofSymbolException e)
        {
            throw new Error(new UndefinedEofSymbolException
                                ("The Lexer does not implement the Eof symbol " +
                                 UPCExpressionParsersym.orderedTerminalSymbols[UPCExpressionParserprs.EOFT_SYMBOL]));
        } 
    }

    public String[] orderedTerminalSymbols() { return UPCExpressionParsersym.orderedTerminalSymbols; }
    public String getTokenKindName(int kind) { return UPCExpressionParsersym.orderedTerminalSymbols[kind]; }
    public int getEOFTokenKind() { return UPCExpressionParserprs.EOFT_SYMBOL; }
    public PrsStream getParseStream() { return (PrsStream) this; }
    
    //
    // Report error message for given error_token.
    //
    public final void reportErrorTokenMessage(int error_token, String msg)
    {
        int firsttok = super.getFirstErrorToken(error_token),
            lasttok = super.getLastErrorToken(error_token);
        String location = super.getFileName() + ':' +
                          (firsttok > lasttok
                                    ? (super.getEndLine(lasttok) + ":" + super.getEndColumn(lasttok))
                                    : (super.getLine(error_token) + ":" +
                                       super.getColumn(error_token) + ":" +
                                       super.getEndLine(error_token) + ":" +
                                       super.getEndColumn(error_token)))
                          + ": ";
        super.reportError((firsttok > lasttok ? ParseErrorCodes.INSERTION_CODE : ParseErrorCodes.SUBSTITUTION_CODE), location, msg);
    }

    public void parser()
    {
        parser(null, 0);
    }
    
    public void parser(Monitor monitor)
    {
        parser(monitor, 0);
    }
    
    public void parser(int error_repair_count)
    {
        parser(null, error_repair_count);
    }

    public void parser(Monitor monitor, int error_repair_count)
    {
        try
        {
            btParser = new FixedBacktrackingParser(monitor, (TokenStream) this, prs, (RuleAction) this);
        }
        catch (NotBacktrackParseTableException e)
        {
            throw new Error(new NotBacktrackParseTableException
                                ("Regenerate UPCExpressionParserprs.java with -BACKTRACK option"));
        }
        catch (BadParseSymFileException e)
        {
            throw new Error(new BadParseSymFileException("Bad Parser Symbol File -- UPCExpressionParsersym.java"));
        }

        try
        {
            btParser.parse(error_repair_count);
        }
        catch (BadParseException e)
        {
            reset(e.error_token); // point to error token
            DiagnoseParser diagnoseParser = new DiagnoseParser(this, prs);
            diagnoseParser.diagnose(e.error_token);
        }
    }


private  UPCParserAction  action;
private IASTCompletionNode compNode;

public UPCExpressionParser() {  // constructor
}

private void initActions(Set<IParser.Options> options) {
	ScopedStack<Object> astStack = new ScopedStack<Object>();
	
	action = new  UPCParserAction (this, astStack,  new UPCASTNodeFactory() ,  UPCSecondaryParserFactory.getDefault() );
	action.setParserOptions(options);
	
	 
}


public void addToken(IToken token) {
	token.setKind(mapKind(token.getKind())); // TODO does mapKind need to be called?
	super.addToken(token);
}


public  IASTExpression  parse(Set<IParser.Options> options) {
	// this has to be done, or... kaboom!
	setStreamLength(getSize());
	initActions(options);
	
	final int errorRepairCount = -1;  // -1 means full error handling
	parser(null, errorRepairCount); // do the actual parse
	super.resetTokenStream(); // allow tokens to be garbage collected

	compNode = action.getASTCompletionNode(); // the completion node may be null
	return ( IASTExpression ) action.getParseResult();
}


public IASTCompletionNode getCompletionNode() {
	return compNode;
}

// uncomment this method to use with backtracking parser
public List<IToken> getRuleTokens() {
    return getTokens().subList(getLeftSpan(), getRightSpan() + 1);
}

public String[] getOrderedTerminalSymbols() {
	return UPCExpressionParsersym.orderedTerminalSymbols;
}

@SuppressWarnings("nls")
public String getName() {
	return "UPCExpressionParser";
}



private ITokenMap tokenMap = null;

public void setTokens(List<IToken> tokens) {
	resetTokenStream();
	addToken(new Token(null, 0, 0, 0)); // dummy token
	for(IToken token : tokens) {
		token.setKind(tokenMap.mapKind(token.getKind()));
		addToken(token);
	}
	addToken(new Token(null, 0, 0, UPCExpressionParsersym.TK_EOF_TOKEN));
}

public UPCExpressionParser(IParserActionTokenProvider parser) {  // constructor
	tokenMap = new TokenMap(UPCExpressionParsersym.orderedTerminalSymbols, parser.getOrderedTerminalSymbols());
}	



    public void ruleAction(int ruleNumber)
    {
        switch (ruleNumber)
        {
  
            //
            // Rule 1:  <openscope-ast> ::= $Empty
            //
            case 1: { action.   openASTScope();             break;
            }  
  
            //
            // Rule 12:  literal ::= integer
            //
            case 12: { action.   consumeExpressionLiteral(IASTLiteralExpression.lk_integer_constant);            break;
            }  
  
            //
            // Rule 13:  literal ::= floating
            //
            case 13: { action.   consumeExpressionLiteral(IASTLiteralExpression.lk_float_constant);             break;
            }  
  
            //
            // Rule 14:  literal ::= charconst
            //
            case 14: { action.   consumeExpressionLiteral(IASTLiteralExpression.lk_char_constant);              break;
            }  
  
            //
            // Rule 15:  literal ::= stringlit
            //
            case 15: { action.   consumeExpressionLiteral(IASTLiteralExpression.lk_string_literal);             break;
            }  
  
            //
            // Rule 17:  primary_expression ::= primary_expression_id
            //
            case 17: { action.   consumeExpressionID();             break;
            }  
  
            //
            // Rule 18:  primary_expression ::= ( expression )
            //
            case 18: { action.   consumeExpressionBracketed();             break;
            }  
  
            //
            // Rule 21:  postfix_expression ::= postfix_expression [ expression ]
            //
            case 21: { action.   consumeExpressionArraySubscript();             break;
            }  
  
            //
            // Rule 22:  postfix_expression ::= postfix_expression ( expression_list_opt )
            //
            case 22: { action.   consumeExpressionFunctionCall();             break;
            }  
  
            //
            // Rule 23:  postfix_expression ::= postfix_expression . member_name
            //
            case 23: { action.   consumeExpressionFieldReference(false);             break;
            }  
  
            //
            // Rule 24:  postfix_expression ::= postfix_expression -> member_name
            //
            case 24: { action.   consumeExpressionFieldReference(true);             break;
            }  
  
            //
            // Rule 25:  postfix_expression ::= postfix_expression ++
            //
            case 25: { action.    consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixIncr);             break;
            }  
  
            //
            // Rule 26:  postfix_expression ::= postfix_expression --
            //
            case 26: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_postFixDecr);             break;
            }  
  
            //
            // Rule 27:  postfix_expression ::= ( type_id ) { <openscope-ast> initializer_list comma_opt }
            //
            case 27: { action.   consumeExpressionTypeIdInitializer();             break;
            }  
  
            //
            // Rule 32:  unary_expression ::= ++ unary_expression
            //
            case 32: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixIncr);             break;
            }  
  
            //
            // Rule 33:  unary_expression ::= -- unary_expression
            //
            case 33: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_prefixDecr);             break;
            }  
  
            //
            // Rule 34:  unary_expression ::= & cast_expression
            //
            case 34: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_amper);             break;
            }  
  
            //
            // Rule 35:  unary_expression ::= * cast_expression
            //
            case 35: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_star);             break;
            }  
  
            //
            // Rule 36:  unary_expression ::= + cast_expression
            //
            case 36: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_plus);             break;
            }  
  
            //
            // Rule 37:  unary_expression ::= - cast_expression
            //
            case 37: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_minus);             break;
            }  
  
            //
            // Rule 38:  unary_expression ::= ~ cast_expression
            //
            case 38: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_tilde);             break;
            }  
  
            //
            // Rule 39:  unary_expression ::= ! cast_expression
            //
            case 39: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_not);             break;
            }  
  
            //
            // Rule 40:  unary_expression ::= sizeof unary_expression
            //
            case 40: { action.   consumeExpressionUnaryOperator(IASTUnaryExpression.op_sizeof);             break;
            }  
  
            //
            // Rule 41:  unary_expression ::= sizeof ( type_id )
            //
            case 41: { action.   consumeExpressionTypeId(IASTTypeIdExpression.op_sizeof);             break;
            }  
  
            //
            // Rule 43:  cast_expression ::= ( type_id ) cast_expression
            //
            case 43: { action.   consumeExpressionCast(IASTCastExpression.op_cast);             break;
            }  
  
            //
            // Rule 45:  multiplicative_expression ::= multiplicative_expression * cast_expression
            //
            case 45: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_multiply);             break;
            }  
  
            //
            // Rule 46:  multiplicative_expression ::= multiplicative_expression / cast_expression
            //
            case 46: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_divide);             break;
            }  
  
            //
            // Rule 47:  multiplicative_expression ::= multiplicative_expression % cast_expression
            //
            case 47: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_modulo);             break;
            }  
  
            //
            // Rule 49:  additive_expression ::= additive_expression + multiplicative_expression
            //
            case 49: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_plus);             break;
            }  
  
            //
            // Rule 50:  additive_expression ::= additive_expression - multiplicative_expression
            //
            case 50: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_minus);             break;
            }  
  
            //
            // Rule 52:  shift_expression ::= shift_expression << additive_expression
            //
            case 52: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftLeft);             break;
            }  
  
            //
            // Rule 53:  shift_expression ::= shift_expression >> additive_expression
            //
            case 53: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftRight);             break;
            }  
  
            //
            // Rule 55:  relational_expression ::= relational_expression < shift_expression
            //
            case 55: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_lessThan);             break;
            }  
  
            //
            // Rule 56:  relational_expression ::= relational_expression > shift_expression
            //
            case 56: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_greaterThan);             break;
            }  
  
            //
            // Rule 57:  relational_expression ::= relational_expression <= shift_expression
            //
            case 57: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_lessEqual);             break;
            }  
  
            //
            // Rule 58:  relational_expression ::= relational_expression >= shift_expression
            //
            case 58: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_greaterEqual);             break;
            }  
  
            //
            // Rule 60:  equality_expression ::= equality_expression == relational_expression
            //
            case 60: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_equals);             break;
            }  
  
            //
            // Rule 61:  equality_expression ::= equality_expression != relational_expression
            //
            case 61: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_notequals);             break;
            }  
  
            //
            // Rule 63:  AND_expression ::= AND_expression & equality_expression
            //
            case 63: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryAnd);             break;
            }  
  
            //
            // Rule 65:  exclusive_OR_expression ::= exclusive_OR_expression ^ AND_expression
            //
            case 65: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryXor);             break;
            }  
  
            //
            // Rule 67:  inclusive_OR_expression ::= inclusive_OR_expression | exclusive_OR_expression
            //
            case 67: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryOr);             break;
            }  
  
            //
            // Rule 69:  logical_AND_expression ::= logical_AND_expression && inclusive_OR_expression
            //
            case 69: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_logicalAnd);             break;
            }  
  
            //
            // Rule 71:  logical_OR_expression ::= logical_OR_expression || logical_AND_expression
            //
            case 71: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_logicalOr);             break;
            }  
  
            //
            // Rule 73:  conditional_expression ::= logical_OR_expression ? expression : conditional_expression
            //
            case 73: { action.   consumeExpressionConditional();             break;
            }  
  
            //
            // Rule 75:  assignment_expression ::= unary_expression = assignment_expression
            //
            case 75: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_assign);             break;
            }  
  
            //
            // Rule 76:  assignment_expression ::= unary_expression *= assignment_expression
            //
            case 76: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_multiplyAssign);             break;
            }  
  
            //
            // Rule 77:  assignment_expression ::= unary_expression /= assignment_expression
            //
            case 77: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_divideAssign);             break;
            }  
  
            //
            // Rule 78:  assignment_expression ::= unary_expression %= assignment_expression
            //
            case 78: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_moduloAssign);             break;
            }  
  
            //
            // Rule 79:  assignment_expression ::= unary_expression += assignment_expression
            //
            case 79: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_plusAssign);             break;
            }  
  
            //
            // Rule 80:  assignment_expression ::= unary_expression -= assignment_expression
            //
            case 80: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_minusAssign);             break;
            }  
  
            //
            // Rule 81:  assignment_expression ::= unary_expression <<= assignment_expression
            //
            case 81: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftLeftAssign);             break;
            }  
  
            //
            // Rule 82:  assignment_expression ::= unary_expression >>= assignment_expression
            //
            case 82: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_shiftRightAssign);             break;
            }  
  
            //
            // Rule 83:  assignment_expression ::= unary_expression &= assignment_expression
            //
            case 83: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryAndAssign);             break;
            }  
  
            //
            // Rule 84:  assignment_expression ::= unary_expression ^= assignment_expression
            //
            case 84: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryXorAssign);             break;
            }  
  
            //
            // Rule 85:  assignment_expression ::= unary_expression |= assignment_expression
            //
            case 85: { action.   consumeExpressionBinaryOperator(IASTBinaryExpression.op_binaryOrAssign);             break;
            }  
  
            //
            // Rule 88:  expression_list ::= <openscope-ast> expression_list_actual
            //
            case 88: { action.   consumeExpressionList();             break;
            }  
  
            //
            // Rule 90:  expression_list_opt ::= $Empty
            //
            case 90: { action.   consumeEmpty();             break;
            }  
  
            //
            // Rule 100:  statement ::= ERROR_TOKEN
            //
            case 100: { action.   consumeStatementProblem();             break;
            }  
  
            //
            // Rule 101:  labeled_statement ::= identifier_token : statement
            //
            case 101: { action.   consumeStatementLabeled();             break;
            }  
  
            //
            // Rule 102:  labeled_statement ::= case constant_expression : statement
            //
            case 102: { action.   consumeStatementCase();             break;
            }  
  
            //
            // Rule 103:  labeled_statement ::= default : statement
            //
            case 103: { action.   consumeStatementDefault();             break;
            }  
  
            //
            // Rule 104:  compound_statement ::= { }
            //
            case 104: { action.   consumeStatementCompoundStatement(false);             break;
            }  
  
            //
            // Rule 105:  compound_statement ::= { <openscope-ast> block_item_list }
            //
            case 105: { action.   consumeStatementCompoundStatement(true);             break;
            }  
  
            //
            // Rule 109:  block_item ::= declaration
            //
            case 109: { action.   consumeStatementDeclarationWithDisambiguation();             break;
            }  
  
            //
            // Rule 110:  expression_statement ::= ;
            //
            case 110: { action.   consumeStatementNull();             break;
            }  
  
            //
            // Rule 111:  expression_statement ::= expression_in_statement ;
            //
            case 111: { action.   consumeStatementExpression();             break;
            }  
  
            //
            // Rule 112:  selection_statement ::= if ( expression ) statement
            //
            case 112: { action.   consumeStatementIf(false);             break;
            }  
  
            //
            // Rule 113:  selection_statement ::= if ( expression ) statement else statement
            //
            case 113: { action.   consumeStatementIf(true);             break;
            }  
  
            //
            // Rule 114:  selection_statement ::= switch ( expression ) statement
            //
            case 114: { action.   consumeStatementSwitch();             break;
            }  
  
            //
            // Rule 116:  expression_opt ::= $Empty
            //
            case 116: { action.   consumeEmpty();             break;
            }  
  
            //
            // Rule 117:  iteration_statement ::= do statement while ( expression ) ;
            //
            case 117: { action.   consumeStatementDoLoop();             break;
            }  
  
            //
            // Rule 118:  iteration_statement ::= while ( expression ) statement
            //
            case 118: { action.   consumeStatementWhileLoop();             break;
            }  
  
            //
            // Rule 119:  iteration_statement ::= for ( expression_opt ; expression_opt ; expression_opt ) statement
            //
            case 119: { action.   consumeStatementForLoop();             break;
            }  
  
            //
            // Rule 120:  iteration_statement ::= for ( declaration expression_opt ; expression_opt ) statement
            //
            case 120: { action.   consumeStatementForLoop();             break;
            }  
  
            //
            // Rule 121:  jump_statement ::= goto identifier_token ;
            //
            case 121: { action.   consumeStatementGoto();             break;
            }  
  
            //
            // Rule 122:  jump_statement ::= continue ;
            //
            case 122: { action.   consumeStatementContinue();             break;
            }  
  
            //
            // Rule 123:  jump_statement ::= break ;
            //
            case 123: { action.   consumeStatementBreak();             break;
            }  
  
            //
            // Rule 124:  jump_statement ::= return ;
            //
            case 124: { action.   consumeStatementReturn(false);             break;
            }  
  
            //
            // Rule 125:  jump_statement ::= return expression ;
            //
            case 125: { action.   consumeStatementReturn(true);             break;
            }  
  
            //
            // Rule 126:  declaration ::= declaration_specifiers ;
            //
            case 126: { action.   consumeDeclarationSimple(false);             break;
            }  
  
            //
            // Rule 127:  declaration ::= declaration_specifiers <openscope-ast> init_declarator_list ;
            //
            case 127: { action.   consumeDeclarationSimple(true);             break;
            }  
  
            //
            // Rule 128:  declaration_specifiers ::= <openscope-ast> simple_declaration_specifiers
            //
            case 128: { action.   consumeDeclarationSpecifiersSimple();             break;
            }  
  
            //
            // Rule 129:  declaration_specifiers ::= <openscope-ast> struct_or_union_declaration_specifiers
            //
            case 129: { action.   consumeDeclarationSpecifiersStructUnionEnum();             break;
            }  
  
            //
            // Rule 130:  declaration_specifiers ::= <openscope-ast> elaborated_declaration_specifiers
            //
            case 130: { action.   consumeDeclarationSpecifiersStructUnionEnum();             break;
            }  
  
            //
            // Rule 131:  declaration_specifiers ::= <openscope-ast> enum_declaration_specifiers
            //
            case 131: { action.   consumeDeclarationSpecifiersStructUnionEnum();             break;
            }  
  
            //
            // Rule 132:  declaration_specifiers ::= <openscope-ast> typdef_name_declaration_specifiers
            //
            case 132: { action.   consumeDeclarationSpecifiersTypedefName();             break;
            }  
  
            //
            // Rule 157:  init_declarator ::= complete_declarator = initializer
            //
            case 157: { action.   consumeDeclaratorWithInitializer(true);             break;
            }  
  
            //
            // Rule 159:  storage_class_specifier ::= storage_class_specifier_token
            //
            case 159: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 165:  simple_type_specifier ::= simple_type_specifier_token
            //
            case 165: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 178:  type_name_specifier ::= identifier_token
            //
            case 178: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 179:  struct_or_union_specifier ::= struct_or_union struct_or_union_specifier_hook { <openscope-ast> struct_declaration_list_opt }
            //
            case 179: { action.   consumeTypeSpecifierComposite(false);            break;
            }  
  
            //
            // Rule 180:  struct_or_union_specifier ::= struct_or_union struct_or_union_specifier_hook identifier_token struct_or_union_specifier_suffix_hook { <openscope-ast> struct_declaration_list_opt }
            //
            case 180: { action.   consumeTypeSpecifierComposite(true);            break;
            }  
  
            //
            // Rule 185:  elaborated_specifier ::= struct elaborated_specifier_hook identifier_token
            //
            case 185: { action.   consumeTypeSpecifierElaborated(IASTCompositeTypeSpecifier.k_struct);            break;
            }  
  
            //
            // Rule 186:  elaborated_specifier ::= union elaborated_specifier_hook identifier_token
            //
            case 186: { action.   consumeTypeSpecifierElaborated(IASTCompositeTypeSpecifier.k_union);            break;
            }  
  
            //
            // Rule 187:  elaborated_specifier ::= enum elaborated_specifier_hook identifier_token
            //
            case 187: { action.   consumeTypeSpecifierElaborated(IASTElaboratedTypeSpecifier.k_enum);            break;
            }  
  
            //
            // Rule 193:  struct_declaration ::= specifier_qualifier_list <openscope-ast> struct_declarator_list ;
            //
            case 193: { action.   consumeStructDeclaration(true);             break;
            }  
  
            //
            // Rule 194:  struct_declaration ::= specifier_qualifier_list ;
            //
            case 194: { action.   consumeStructDeclaration(false);             break;
            }  
  
            //
            // Rule 195:  struct_declaration ::= ERROR_TOKEN
            //
            case 195: { action.   consumeDeclarationProblem();             break;
            }  
  
            //
            // Rule 201:  struct_declarator ::= : constant_expression
            //
            case 201: { action.   consumeBitField(false);             break;
            }  
  
            //
            // Rule 202:  struct_declarator ::= declarator : constant_expression
            //
            case 202: { action.   consumeBitField(true);             break;
            }  
  
            //
            // Rule 203:  enum_specifier ::= enum enum_specifier_hook { <openscope-ast> enumerator_list_opt comma_opt }
            //
            case 203: { action.   consumeTypeSpecifierEnumeration(false);            break;
            }  
  
            //
            // Rule 204:  enum_specifier ::= enum enum_specifier_hook identifier_token { <openscope-ast> enumerator_list_opt comma_opt }
            //
            case 204: { action.   consumeTypeSpecifierEnumeration(true);            break;
            }  
  
            //
            // Rule 210:  enumerator ::= identifier_token
            //
            case 210: { action.   consumeEnumerator(false);            break;
            }  
  
            //
            // Rule 211:  enumerator ::= identifier_token = constant_expression
            //
            case 211: { action.   consumeEnumerator(true);            break;
            }  
  
            //
            // Rule 212:  type_qualifier ::= type_qualifier_token
            //
            case 212: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 216:  function_specifier ::= inline
            //
            case 216: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 218:  declarator ::= <openscope-ast> pointer_seq direct_declarator
            //
            case 218: { action.   consumeDeclaratorWithPointer(true);             break;
            }  
  
            //
            // Rule 223:  basic_direct_declarator ::= declarator_id_name
            //
            case 223: { action.   consumeDirectDeclaratorIdentifier();             break;
            }  
  
            //
            // Rule 224:  basic_direct_declarator ::= ( declarator )
            //
            case 224: { action.   consumeDirectDeclaratorBracketed();             break;
            }  
  
            //
            // Rule 225:  declarator_id_name ::= identifier
            //
            case 225: { action.   consumeIdentifierName();             break;
            }  
  
            //
            // Rule 226:  array_direct_declarator ::= basic_direct_declarator array_modifier
            //
            case 226: { action.   consumeDirectDeclaratorArrayDeclarator(true);             break;
            }  
  
            //
            // Rule 227:  array_direct_declarator ::= array_direct_declarator array_modifier
            //
            case 227: { action.   consumeDirectDeclaratorArrayDeclarator(true);             break;
            }  
  
            //
            // Rule 229:  function_direct_declarator ::= basic_direct_declarator ( <openscope-ast> parameter_type_list )
            //
            case 229: { action.   consumeDirectDeclaratorFunctionDeclarator(true, true);             break;
            }  
  
            //
            // Rule 230:  function_direct_declarator ::= basic_direct_declarator ( )
            //
            case 230: { action.   consumeDirectDeclaratorFunctionDeclarator(true, false);             break;
            }  
  
            //
            // Rule 232:  function_declarator ::= <openscope-ast> pointer_seq function_direct_declarator
            //
            case 232: { action.   consumeDeclaratorWithPointer(true);             break;
            }  
  
            //
            // Rule 233:  knr_direct_declarator ::= basic_direct_declarator ( <openscope-ast> identifier_list )
            //
            case 233: { action.   consumeDirectDeclaratorFunctionDeclaratorKnR();             break;
            }  
  
            //
            // Rule 235:  knr_function_declarator ::= <openscope-ast> pointer_seq knr_direct_declarator
            //
            case 235: { action.   consumeDeclaratorWithPointer(true);             break;
            }  
  
            //
            // Rule 236:  identifier_list ::= identifier
            //
            case 236: { action.   consumeIdentifierKnR();             break;
            }  
  
            //
            // Rule 237:  identifier_list ::= identifier_list , identifier
            //
            case 237: { action.   consumeIdentifierKnR();             break;
            }  
  
            //
            // Rule 238:  array_modifier ::= [ ]
            //
            case 238: { action.   consumeDirectDeclaratorArrayModifier(false);             break;
            }  
  
            //
            // Rule 239:  array_modifier ::= [ <openscope-ast> array_modifier_type_qualifiers ]
            //
            case 239: { action.   consumeDirectDeclaratorModifiedArrayModifier(false, false, true, false);             break;
            }  
  
            //
            // Rule 240:  array_modifier ::= [ assignment_expression ]
            //
            case 240: { action.   consumeDirectDeclaratorArrayModifier(true);             break;
            }  
  
            //
            // Rule 241:  array_modifier ::= [ <openscope-ast> array_modifier_type_qualifiers assignment_expression ]
            //
            case 241: { action.   consumeDirectDeclaratorModifiedArrayModifier(false, false, true, true);             break;
            }  
  
            //
            // Rule 242:  array_modifier ::= [ static assignment_expression ]
            //
            case 242: { action.   consumeDirectDeclaratorModifiedArrayModifier(true, false, false, true);             break;
            }  
  
            //
            // Rule 243:  array_modifier ::= [ static <openscope-ast> array_modifier_type_qualifiers assignment_expression ]
            //
            case 243: { action.   consumeDirectDeclaratorModifiedArrayModifier(true, false, true, true);             break;
            }  
  
            //
            // Rule 244:  array_modifier ::= [ <openscope-ast> array_modifier_type_qualifiers static assignment_expression ]
            //
            case 244: { action.   consumeDirectDeclaratorModifiedArrayModifier(true, false, true, true);             break;
            }  
  
            //
            // Rule 245:  array_modifier ::= [ * ]
            //
            case 245: { action.   consumeDirectDeclaratorModifiedArrayModifier(false, true, false, false);             break;
            }  
  
            //
            // Rule 246:  array_modifier ::= [ <openscope-ast> array_modifier_type_qualifiers * ]
            //
            case 246: { action.   consumeDirectDeclaratorModifiedArrayModifier(false, true, true, false);             break;
            }  
  
            //
            // Rule 248:  pointer_seq ::= pointer_hook *
            //
            case 248: { action.   consumePointer();             break;
            }  
  
            //
            // Rule 249:  pointer_seq ::= pointer_seq pointer_hook *
            //
            case 249: { action.   consumePointer();             break;
            }  
  
            //
            // Rule 250:  pointer_seq ::= pointer_hook * <openscope-ast> type_qualifier_list
            //
            case 250: { action.   consumePointerTypeQualifierList();             break;
            }  
  
            //
            // Rule 251:  pointer_seq ::= pointer_seq pointer_hook * <openscope-ast> type_qualifier_list
            //
            case 251: { action.   consumePointerTypeQualifierList();             break;
            }  
  
            //
            // Rule 255:  parameter_type_list ::= parameter_list
            //
            case 255: { action.   consumeEmpty();             break;
            }  
  
            //
            // Rule 256:  parameter_type_list ::= parameter_list , ...
            //
            case 256: { action.   consumePlaceHolder();             break;
            }  
  
            //
            // Rule 257:  parameter_type_list ::= ...
            //
            case 257: { action.   consumePlaceHolder();             break;
            }  
  
            //
            // Rule 260:  parameter_declaration ::= declaration_specifiers complete_parameter_declarator
            //
            case 260: { action.   consumeParameterDeclaration();             break;
            }  
  
            //
            // Rule 261:  parameter_declaration ::= declaration_specifiers
            //
            case 261: { action.   consumeParameterDeclarationWithoutDeclarator();             break;
            }  
  
            //
            // Rule 264:  type_id ::= specifier_qualifier_list
            //
            case 264: { action.   consumeTypeId(false);             break;
            }  
  
            //
            // Rule 265:  type_id ::= specifier_qualifier_list abstract_declarator
            //
            case 265: { action.   consumeTypeId(true);             break;
            }  
  
            //
            // Rule 267:  abstract_declarator ::= <openscope-ast> pointer_seq
            //
            case 267: { action.   consumeDeclaratorWithPointer(false);             break;
            }  
  
            //
            // Rule 268:  abstract_declarator ::= <openscope-ast> pointer_seq direct_abstract_declarator
            //
            case 268: { action.   consumeDeclaratorWithPointer(false);             break;
            }  
  
            //
            // Rule 272:  basic_direct_abstract_declarator ::= ( abstract_declarator )
            //
            case 272: { action.   consumeDirectDeclaratorBracketed();             break;
            }  
  
            //
            // Rule 273:  array_direct_abstract_declarator ::= array_modifier
            //
            case 273: { action.   consumeDirectDeclaratorArrayDeclarator(false);             break;
            }  
  
            //
            // Rule 274:  array_direct_abstract_declarator ::= array_direct_abstract_declarator array_modifier
            //
            case 274: { action.   consumeDirectDeclaratorArrayDeclarator(true);             break;
            }  
  
            //
            // Rule 275:  array_direct_abstract_declarator ::= basic_direct_abstract_declarator array_modifier
            //
            case 275: { action.   consumeDirectDeclaratorArrayDeclarator(true);             break;
            }  
  
            //
            // Rule 276:  function_direct_abstract_declarator ::= ( )
            //
            case 276: { action.   consumeDirectDeclaratorFunctionDeclarator(false, false);             break;
            }   
  
            //
            // Rule 277:  function_direct_abstract_declarator ::= basic_direct_abstract_declarator ( )
            //
            case 277: { action.   consumeDirectDeclaratorFunctionDeclarator(true, false);             break;
            }  
  
            //
            // Rule 278:  function_direct_abstract_declarator ::= ( <openscope-ast> parameter_type_list )
            //
            case 278: { action.   consumeDirectDeclaratorFunctionDeclarator(false, true);             break;
            }  
  
            //
            // Rule 279:  function_direct_abstract_declarator ::= basic_direct_abstract_declarator ( <openscope-ast> parameter_type_list )
            //
            case 279: { action.   consumeDirectDeclaratorFunctionDeclarator(true, true);             break;
            }  
  
            //
            // Rule 280:  initializer ::= assignment_expression
            //
            case 280: { action.   consumeInitializer();             break;
            }  
  
            //
            // Rule 281:  initializer ::= start_initializer_list { <openscope-ast> initializer_list comma_opt } end_initializer_list
            //
            case 281: { action.   consumeInitializerList();             break;
            }  
  
            //
            // Rule 282:  initializer ::= { <openscope-ast> }
            //
            case 282: { action.   consumeInitializerList();             break;
            }  
  
            //
            // Rule 283:  start_initializer_list ::= $Empty
            //
            case 283: { action.   initializerListStart();            break;
            }  
  
            //
            // Rule 284:  end_initializer_list ::= $Empty
            //
            case 284: { action.   initializerListEnd();            break;
            }  
  
            //
            // Rule 289:  designated_initializer ::= <openscope-ast> designation = initializer
            //
            case 289: { action.   consumeInitializerDesignated();             break;
            }  
  
            //
            // Rule 293:  designator_base ::= [ constant_expression ]
            //
            case 293: { action.   consumeDesignatorArray();             break;
            }  
  
            //
            // Rule 294:  designator_base ::= . identifier_token
            //
            case 294: { action.   consumeDesignatorField();             break;
            }  
  
            //
            // Rule 295:  designator ::= [ constant_expression ]
            //
            case 295: { action.   consumeDesignatorArray();             break;
            }  
  
            //
            // Rule 296:  designator ::= . identifier_token
            //
            case 296: { action.   consumeDesignatorField();             break;
            }  
  
            //
            // Rule 297:  translation_unit ::= external_declaration_list
            //
            case 297: { action.   consumeTranslationUnit();             break;
            }   
  
            //
            // Rule 298:  translation_unit ::= $Empty
            //
            case 298: { action.   consumeTranslationUnit();             break;
            }  
  
            //
            // Rule 303:  external_declaration ::= ;
            //
            case 303: { action.   consumeDeclarationEmpty();             break;
            }  
  
            //
            // Rule 304:  external_declaration ::= ERROR_TOKEN
            //
            case 304: { action.   consumeDeclarationProblem();             break;
            }  
  
            //
            // Rule 307:  function_definition ::= declaration_specifiers <openscope-ast> function_declarator function_body
            //
            case 307: { action.   consumeFunctionDefinition(true);             break;
            }  
  
            //
            // Rule 308:  function_definition ::= <openscope-ast> function_declarator function_body
            //
            case 308: { action.   consumeFunctionDefinition(false);             break;
            }  
  
            //
            // Rule 309:  function_definition ::= declaration_specifiers <openscope-ast> knr_function_declarator <openscope-ast> declaration_list compound_statement
            //
            case 309: { action.   consumeFunctionDefinitionKnR();             break;
            }  
  
            //
            // Rule 310:  function_body ::= { }
            //
            case 310: { action.   consumeStatementCompoundStatement(false);             break;
            }  
  
            //
            // Rule 311:  function_body ::= { <openscope-ast> block_item_list }
            //
            case 311: { action.   consumeStatementCompoundStatement(true);             break;
            }  
  
            //
            // Rule 313:  expression_parser_start ::= ERROR_TOKEN
            //
            case 313: { action.   consumeEmpty();             break;
            }  
  
            //
            // Rule 314:  literal ::= MYTHREAD
            //
            case 314: { action.   consumeKeywordExpression(IUPCASTKeywordExpression.kw_mythread);            break;
            }  
  
            //
            // Rule 315:  literal ::= THREADS
            //
            case 315: { action.   consumeKeywordExpression(IUPCASTKeywordExpression.kw_threads);            break;
            }  
  
            //
            // Rule 316:  literal ::= UPC_MAX_BLOCKSIZE
            //
            case 316: { action.   consumeKeywordExpression(IUPCASTKeywordExpression.kw_upc_max_block_size);            break;
            }  
  
            //
            // Rule 317:  unary_expression ::= upc_localsizeof unary_expression
            //
            case 317: { action.   consumeExpressionUnarySizeofOperator(IUPCASTUnarySizeofExpression.upc_localsizeof);            break;
            }  
  
            //
            // Rule 318:  unary_expression ::= upc_localsizeof ( type_id )
            //
            case 318: { action.   consumeExpressionSizeofTypeId(IUPCASTUnarySizeofExpression.upc_localsizeof);            break;
            }  
  
            //
            // Rule 319:  unary_expression ::= upc_blocksizeof unary_expression
            //
            case 319: { action.   consumeExpressionUnarySizeofOperator(IUPCASTUnarySizeofExpression.upc_blocksizeof);            break;
            }  
  
            //
            // Rule 320:  unary_expression ::= upc_blocksizeof ( type_id )
            //
            case 320: { action.   consumeExpressionSizeofTypeId(IUPCASTUnarySizeofExpression.upc_blocksizeof);            break;
            }  
  
            //
            // Rule 321:  unary_expression ::= upc_elemsizeof unary_expression
            //
            case 321: { action.   consumeExpressionUnarySizeofOperator(IUPCASTUnarySizeofExpression.upc_elemsizeof);            break;
            }  
  
            //
            // Rule 322:  unary_expression ::= upc_elemsizeof ( type_id )
            //
            case 322: { action.   consumeExpressionSizeofTypeId(IUPCASTUnarySizeofExpression.upc_elemsizeof);            break;
            }  
  
            //
            // Rule 326:  shared_type_qualifier ::= shared
            //
            case 326: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 327:  reference_type_qualifier ::= relaxed
            //
            case 327: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 328:  reference_type_qualifier ::= strict
            //
            case 328: { action.   consumeToken();             break;
            }  
  
            //
            // Rule 329:  layout_qualifier ::= [ constant_expression ]
            //
            case 329: { action.   consumeLayoutQualifier(true, false);             break;
            }  
  
            //
            // Rule 330:  layout_qualifier ::= [ * ]
            //
            case 330: { action.   consumeLayoutQualifier(false, true);             break;
            }  
  
            //
            // Rule 331:  layout_qualifier ::= [ ]
            //
            case 331: { action.   consumeLayoutQualifier(false, false);             break;
            }  
  
            //
            // Rule 333:  synchronization_statement ::= upc_notify expression ;
            //
            case 333: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_notify, true);            break;
            }  
  
            //
            // Rule 334:  synchronization_statement ::= upc_notify ;
            //
            case 334: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_notify, false);            break;
            }  
  
            //
            // Rule 335:  synchronization_statement ::= upc_wait expression ;
            //
            case 335: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_wait, true);            break;
            }  
  
            //
            // Rule 336:  synchronization_statement ::= upc_wait ;
            //
            case 336: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_wait, false);            break;
            }  
  
            //
            // Rule 337:  synchronization_statement ::= upc_barrier expression ;
            //
            case 337: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_barrier, true);            break;
            }  
  
            //
            // Rule 338:  synchronization_statement ::= upc_barrier ;
            //
            case 338: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_barrier, false);            break;
            }  
  
            //
            // Rule 339:  synchronization_statement ::= upc_fence ;
            //
            case 339: { action.   consumeStatementSynchronizationStatement(IUPCASTSynchronizationStatement.st_upc_fence, false);            break;
            }  
  
            //
            // Rule 340:  iteration_statement ::= upc_forall ( expression ; expression ; expression ; affinity ) statement
            //
            case 340: { action.   consumeStatementUPCForallLoop(true, true, true, true);            break;
            }  
  
            //
            // Rule 341:  iteration_statement ::= upc_forall ( expression ; expression ; expression ; ) statement
            //
            case 341: { action.   consumeStatementUPCForallLoop(true, true, true, false);            break;
            }  
  
            //
            // Rule 342:  iteration_statement ::= upc_forall ( expression ; expression ; ; affinity ) statement
            //
            case 342: { action.   consumeStatementUPCForallLoop(true, true, false, true);            break;
            }  
  
            //
            // Rule 343:  iteration_statement ::= upc_forall ( expression ; expression ; ; ) statement
            //
            case 343: { action.   consumeStatementUPCForallLoop(true, true, false, false);            break;
            }  
  
            //
            // Rule 344:  iteration_statement ::= upc_forall ( expression ; ; expression ; affinity ) statement
            //
            case 344: { action.   consumeStatementUPCForallLoop(true, false, true, true);            break;
            }  
  
            //
            // Rule 345:  iteration_statement ::= upc_forall ( expression ; ; expression ; ) statement
            //
            case 345: { action.   consumeStatementUPCForallLoop(true, false, true, false);            break;
            }  
  
            //
            // Rule 346:  iteration_statement ::= upc_forall ( expression ; ; ; affinity ) statement
            //
            case 346: { action.   consumeStatementUPCForallLoop(true, false, false, true);            break;
            }  
  
            //
            // Rule 347:  iteration_statement ::= upc_forall ( expression ; ; ; ) statement
            //
            case 347: { action.   consumeStatementUPCForallLoop(true, false, false, false);            break;
            }  
  
            //
            // Rule 348:  iteration_statement ::= upc_forall ( ; expression ; expression ; affinity ) statement
            //
            case 348: { action.   consumeStatementUPCForallLoop(false, true, true, true);            break;
            }  
  
            //
            // Rule 349:  iteration_statement ::= upc_forall ( ; expression ; expression ; ) statement
            //
            case 349: { action.   consumeStatementUPCForallLoop(false, true, true, false);            break;
            }  
  
            //
            // Rule 350:  iteration_statement ::= upc_forall ( ; expression ; ; affinity ) statement
            //
            case 350: { action.   consumeStatementUPCForallLoop(false, true, false, true);            break;
            }  
  
            //
            // Rule 351:  iteration_statement ::= upc_forall ( ; expression ; ; ) statement
            //
            case 351: { action.   consumeStatementUPCForallLoop(false, true, false, false);            break;
            }  
  
            //
            // Rule 352:  iteration_statement ::= upc_forall ( ; ; expression ; affinity ) statement
            //
            case 352: { action.   consumeStatementUPCForallLoop(false, false, true, true);            break;
            }  
  
            //
            // Rule 353:  iteration_statement ::= upc_forall ( ; ; expression ; ) statement
            //
            case 353: { action.   consumeStatementUPCForallLoop(false, false, true, false);            break;
            }  
  
            //
            // Rule 354:  iteration_statement ::= upc_forall ( ; ; ; affinity ) statement
            //
            case 354: { action.   consumeStatementUPCForallLoop(false, false, false, true);            break;
            }  
  
            //
            // Rule 355:  iteration_statement ::= upc_forall ( ; ; ; ) statement
            //
            case 355: { action.   consumeStatementUPCForallLoop(false, false, false, false);            break;
            }  
  
            //
            // Rule 356:  iteration_statement ::= upc_forall ( declaration expression ; expression ; affinity ) statement
            //
            case 356: { action.   consumeStatementUPCForallLoop(true, true, true, true);            break;
            }  
  
            //
            // Rule 357:  iteration_statement ::= upc_forall ( declaration expression ; expression ; ) statement
            //
            case 357: { action.   consumeStatementUPCForallLoop(true, true, true, false);            break;
            }  
  
            //
            // Rule 358:  iteration_statement ::= upc_forall ( declaration expression ; ; affinity ) statement
            //
            case 358: { action.   consumeStatementUPCForallLoop(true, true, false, true);            break;
            }  
  
            //
            // Rule 359:  iteration_statement ::= upc_forall ( declaration expression ; ; ) statement
            //
            case 359: { action.   consumeStatementUPCForallLoop(true, true, false, false);            break;
            }  
  
            //
            // Rule 360:  iteration_statement ::= upc_forall ( declaration ; expression ; affinity ) statement
            //
            case 360: { action.   consumeStatementUPCForallLoop(true, false, true, true);            break;
            }  
  
            //
            // Rule 361:  iteration_statement ::= upc_forall ( declaration ; expression ; ) statement
            //
            case 361: { action.   consumeStatementUPCForallLoop(true, false, true, false);            break;
            }  
  
            //
            // Rule 362:  iteration_statement ::= upc_forall ( declaration ; ; affinity ) statement
            //
            case 362: { action.   consumeStatementUPCForallLoop(true, false, false, true);            break;
            }  
  
            //
            // Rule 363:  iteration_statement ::= upc_forall ( declaration ; ; ) statement
            //
            case 363: { action.   consumeStatementUPCForallLoop(true, false, false, false);            break;
            }  
  
            //
            // Rule 365:  affinity ::= continue
            //
            case 365: { action.   consumeToken();             break;
            }  

    
            default:
                break;
        }
        return;
    }
}

